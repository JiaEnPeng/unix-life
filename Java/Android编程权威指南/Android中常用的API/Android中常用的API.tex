% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=java,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{Android中常用的API \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

% \tableofcontents

% \clearpage

\section{Activity类}
\subsection{findViewById}
	函数声明如下：
	\begin{lstlisting}
	public view findViewById(int id);
	\end{lstlisting}

	该方法以组件的资源ID作为参数，返回一个视图对象。需要注意的事，赋值前，需要先将返回的View转型。

\subsection{getActivity}
	函数声明如下：
	\begin{lstlisting}
	Activity getActivity();
	\end{lstlisting}

	返回当前的activity。

\subsection{getIntent}
	函数声明如下：
	\begin{lstlisting}
	Intent getIntent (String uri);
	\end{lstlisting}

	Activity.getIntent()方法返回了由startActivity(Intent)方法转发的Intent对象。

\subsection{onActivityResult}
	函数声明如下：
	\begin{lstlisting}
	protected void onActivityResult(int requestCode, int resultCode, Intent data);
	\end{lstlisting}

	当用户从子activity返回到父activity时，ActivityManager将调用onActivityResult()方法，
	这个方法的参数来自于父activity的原始请求代码，以及setResult()方法参数中的结果代码和intent。\par

	使用例子如下：
	\begin{lstlisting}
	public class QuizActivity extends AppCompatActivity{
		private boolean mIsCheater;
		...
		@Override
		protected void onActivityResult(int requestCode, int resultCode, Intent data)
		{
			if(resultCode != Activity.RESULT_OK)
				return;
			
			if(resultCode == REQUEST_CODE_CHEAT)
			{
				if(data == null)
					return;
				mIsCheater = data.getBooleanExtra(EXTRA_ANSWER_SHOWN, false);
			}
		}
	}
	\end{lstlisting}

\subsection{onCreate}
	函数声明如下：
	\begin{lstlisting}
	void onCreate(Bundle);
	\end{lstlisting}

	当Activity子类被调用后，onCreate(Bundle)方法会被调用，用于初始化。\par

	英文介绍如下：\par
	Called when the activity is starting. 
	This is where most initialization should go: calling setContentView(int) to inflate the activity's UI, 
	using findViewById(int) to programmatically interact with widgets in the UI, 
	calling managedQuery(android.net.Uri, String[], String, String[], String) to retrieve cursors for data being displayed, etc.\par

	activity通过覆盖这个方法来准备以下用户界面相关的工作：
	\begin{itemize}
		\item[1.] 实例化组件并将组件放置在屏幕上，调用setContentView()方法。
		\item[2.] 为组件设置监听器以处理用户交互。
		\item[3.] 访问外部模型数据。
	\end{itemize}

\subsection{onSaveInstanceState}
	函数声明如下：
	\begin{lstlisting}
	protected void onSaveInstanceState(Bundle outState);
	\end{lstlisting}

	这个方法通常在onPause()、onStop()和onDestroy()方法之前由系统调用。\par

	onSaveInstanceState()要求activity将自身状态数据保存在Bundle对象中。Bundle是存储字符串键与限定类型值之间映射关系的一种结构。\par

	一般通过覆盖onSaveInstanceState()方法将一些数据保存在bundle中，然后在onCreate()方法中取回这些数据，从而完成activity销毁与新建之间的数据传递。保存activity的数据：
	\begin{lstlisting}
	public class QuizActivity extends AppCompatActivity {
		private static final String KEY_INDEX = "index";
		...
		@Override
		public void onSaveInstanceState(Bundle savedInstanceState)
		{
			super.onSaveInstanceState(savedInstanceState);
			savedInstanceState.putInt(KEY_INDEX, mCurrentIndex);
		}
	}
	\end{lstlisting}

	取出activity的数据：
	\begin{lstlisting}
	public class QuizActivity extends AppCompatActivity {
		@Override
		protected void onCreate(Bundle savedInstanceState)
		{
			...
			if(savedInstanceState != null)
				mCurrentIndex = savedInstanceState.getInt(KEY_INDEX, 0);
		}
	}
	\end{lstlisting}

\subsection{setContentView}
	函数声明如下：
	\begin{lstlisting}
	public void setContentView(int layoutResID);
	\end{lstlisting}

	根据传入的布局资源ID参数，该方法生成指定布局的视图并将其放置在屏幕上。使用例子如下：
	\begin{lstlisting}
	import android.os.Bundle;
	
	public class QuizActivity extends AppCompatActivity
	{
		@Override
		protected void onCreate(Bundle savedInstanceState)
		{
			super.onCreate(savedInstanceState);
			setContentView(R.layout.activity_quiz);
		}
	}
	\end{lstlisting}

\subsection{setResult}
\subsubsection{只返回结果代码}
	函数声明如下：
	\begin{lstlisting}
	public final void setResult(int resultCode);
	\end{lstlisting}

	如果子activity由startActivityForResult()方法启动，那么result code总是会返回给父activity。
	result code的取值有Activity.RESULT\_OK，Activity.RESULT\_CANCELED。
	如果在没调用setResult()方法的情况下，用户单击了后退按钮，父activity则会收到Activity.RESULT\_CANCELED的结果代码。

\subsubsection{返回附带数据}
	函数声明如下：
	\begin{lstlisting}
	public final void setResult(int resultCode, Intent data);
	\end{lstlisting}

	我们这里通过Intent对象附带数据，从而会传给父activity，例子如下：
	\begin{lstlisting}
	public class CheatActivity extends AppCompatActivity{
		private static final String EXTRA_ANSWER_SHOWN = "com.bignerdranch.android.geoquiz.answer_shown";
		...
		@Override
		protected void onCreate(Bundle savedInstanceState){
			...
			mShowAnswer.setOnClickListener(new View.OnClickListener(){
				@Override
				public void onClick(View v)
				{
					...
					Intent data = new Intent();
					data.putExtra(EXTRA_ANSWER_SHOWN, true);
					setResult(RESULT_OK, data);
				}
			});
		}
	}
	\end{lstlisting}

\subsection{startActivity}
	函数声明如下：
	\begin{lstlisting}
	public void startActivity(Intent intent);
	\end{lstlisting}

	当activity调用startActivity()方法时，调用请求发送给了操作系统的ActivityManager，它负责创建Activity实例并调用其onCreate()方法。
	其中startActivity()方法的Intent类型参数用于指示ActivityManager启动哪个Activity。

	使用例子如下：
	\begin{lstlisting}
	mCheatButton = (Button)findViewById(R.id.cheat_button);
	mCheatButton.setOnClickListener(new View.OnClickListener(){
		@Override
		public void onClick(View v)
		{
			Intent i = new Intent(QuizActivity.this, CheatActivity.class);
			startActivity(i);
		}
	});
	\end{lstlisting}

\subsection{startActivityForResult}
	函数声明如下：
	\begin{lstlisting}
	public void startActivityForResult(Intent intent, int requestCode);
	\end{lstlisting}

	第一个参数是Intent对象，用于指示ActivityManager启动哪个Activity，第二个参数是请求代码。
	请求代码将先被发送给子activity，然后再返回给父activity。
	当一个activity启动多个不同类型的子activity，并且需要判断区分消息回馈方时，通常会用到该请求代码。\par

	使用例子如下：
	\begin{lstlisting}
	public class QuizActivity extends AppCompatActivity{
		...
		private static final int REQUEST_CODE_CHEAT = 0;

		@Override
		protected void onCreate(Bundle savedInstanceState)
		{
			...
			mCheatButton.setOnClickListener(new View.OnClickListener(){
				@Override
				public void onClick(View v)
				{
					...
					Intent i = new Intent(QuizActivity.this, CheatActivity.class);
					startActivityForResult(i, REQUEST_CODE_CHEAT);
				}
			});
		}
	}
	\end{lstlisting}

\section{Bundle类}
	Bundle类对象一般用于保存activity基本数据类型的一些数据，从而实现activity销毁与新建之间的数据传递。

\subsection{getInt}
	函数声明如下：
	\begin{lstlisting}
	int getInt(String key, int defaultValue)
	\end{lstlisting}

\subsection{putInt}
	函数声明如下：
	\begin{lstlisting}
	void putInt (String key, int value)
	\end{lstlisting}

\section{Button类}
\subsection{setOnClickListener}
	函数声明如下：
	\begin{lstlisting}
	void setOnClickListener(View.OnClickListener);
	\end{lstlisting}

	传入SetOnClickListener()方法的监听器参数一般是一个匿名内部类，例子如下：
	\begin{lstlisting}
	import android.widget.Button;

	public class Test extends AppCompatActivity
	{
		private Button mTrueButton;

		@Override
		protected void onCreate(Bundle savedInstanceState)
		{
			super.onCreate(savedInstanceState);

			mTrueButton = (Button)findViewById(R.id.true_button);
			mTrueButton.setOnClickListener(new View.OnClickListener(){
				@Override
				public void onClick(View v){}
			});
		}
	}
	\end{lstlisting}

\section{CharSequence类}
	CharSequence代表着用户输入。

\subsection{toString}
	函数声明如下：
	\begin{lstlisting}
	String toString();
	\end{lstlisting}

	将用户输入转变为字符串。

\section{CheckBox类}
\subsection{setOnCheckedChanged}
	函数声明如下：
	\begin{lstlisting}
	void setOnCheckedChangeListener (CompoundButton.OnCheckedChangeListener listener)
	\end{lstlisting}

	为CheckBox对象设置监听器，例子如下：
	\begin{lstlisting}
	public class CrimeFragment extends Fragment
	{
		...
		@Override
		public void onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
		{
			View v = inflater.inflate(R.layout.fragment_crime, container, false);
			...
			mSolvedCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
				{
					mCrime.setSolved(isChecked);
				}
			});
			...
			return v;
		}
	}
	\end{lstlisting}

\section{EditText类}
\subsection{addTextChangedListener}
	函数声明如下：
	\begin{lstlisting}
	void addTextChangedListener (TextWatcher watcher);
	\end{lstlisting}

	这个方法用于监听文本的输入。\par

	使用例子如下：
	\begin{lstlisting}
	public class CrimeFragment extends Fragment
	{
		...
		@Override
		public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
		{
			...
			mTitleField.addTextChangedListener(new TextWatcher(){
				@Override
				public void beforeTextChanged(CharSequence s, int start, int count, int after)
				{

				}

				@Override
				public void onTextChanged(CharSequence s, int start, int before, int count)
				{
					mCrime.setTitle(s.toString());
				}

				@Override
				public void afterTextChanged(Editable s)
				{

				}
			});
		}
	}
	\end{lstlisting}

\section{FrameActivity类}
\subsection{getSupportFragmentManager}
	函数声明如下：
	\begin{lstlisting}
	FragmentManager getSupportFragmentManager();
	\end{lstlisting}

\section{FragmentManager类}
	FragmentManager类负责管理fragment并将它们的视图添加到activity的视图层级结构中。

\subsection{beginTransaction}
	函数声明如下：
	\begin{lstlisting}
	FragmentTransaction beginTransaction();
	\end{lstlisting}

	返回一个FragmentTransaction实例。

\subsection{findFragmentById}
	函数声明如下：
	\begin{lstlisting}
	Fragment findFragmentById(int id);
	\end{lstlisting}

	根据资源id获得一个Fragment对象。

\section{FragmentTransaction类}
	FragmentTransaction是事务回退栈。

\subsection{add}
	函数声明如下：
	\begin{lstlisting}
	FragmentTransaction add (int containerViewId, Fragment fragment);
	\end{lstlisting}

	用于将一个fragment装载到一个fragment container中。

\section{Intent类}
	Intent对象是component用来与操作系统通信的一种媒介工具。component包括service、activity、broadcast receiver和content provider。

\subsection{Intent构造方法}
	函数声明如下：
	\begin{lstlisting}
	public Intent(Context packageContext, Class<?> cls);
	\end{lstlisting}

	传入该方法的Class类型参数告诉ActivityManager应该启用哪个activiry，Context类型参数告诉ActivityManager参数在哪个actitivy中可以找到它。\par

	使用例子如下：
	\begin{lstlisting}
	mCheatButton = (Button)findViewById(R.id.cheat_button);
	mCheatButton.setOnClickListener(new View.OnClickListener(){
		@Override
		public void onClick(View v)
		{
			Intent i = new Intent(QuizActivity.this, CheatActivity.class);
			startActivity(i);
		}
	});
	\end{lstlisting}

\subsection{getBooleanExtra}
	函数声明如下：
	\begin{lstlisting}
	public boolean getBooleanExtra(String name, boolean defaultValue);
	\end{lstlisting}

\subsection{putExtra}
	函数声明如下：
	\begin{lstlisting}
	public Intent putExtra(String name, boolean value);
	\end{lstlisting}

\section{LayoutInflater类}
\subsection{from}
	函数声明如下：
	\begin{lstlisting}
	LayoutInflater from(Context context);
	\end{lstlisting}

	根据所给的context获得LayoutInflater对象。

\subsection{inflate}
	函数声明如下：
	\begin{lstlisting}
	View inflate (int resource, ViewGroup root, boolean attachToRoot);
	\end{lstlisting}

	该函数通过传入的布局资源ID生成fragment视图，它的第二个参数是视图的父视图，我们需要父视图来正确配置组件。
	第三个参数告知布局生成器是否将生成的视图添加给父视图。

\section{RecyclerView类}
	RecyclerView对象用于回收和定位屏幕上的View对象。
	其中定位View对象的任务交给了LayoutManager，LayoutManager可以在屏幕上定位列表项，还能负责定义屏幕滚动行为。
	而RecyclerView对象借助Adapter子类和ViewHolder子类来显示View对象。

\subsection{指定LayoutManger}
	LayoutManger有很多版本，比如LinearLayoutManager、GridLayoutManager等。使用例子如下：
	\begin{lstlisting}
	public class CrimeListFragment extends Fragment
	{
		private RecyclerView mCrimeRecycleView;

		@Override
		public View onCreateView(LayoutInflater inflater, ViewGroup container, BUndle savedInstanceState)
		{
			View view = inflater.inflate(R.layout.fragment_crime_list, container, false);
			mCrimeRecycleView = (RecyclerView)view.findViewById(R.id.crime_recycler_view);
			mCrimeRecycleView.setLayoutManager(new LinearLayoutManager(getActivity()));

			return view;
		}
	}
	\end{lstlisting}

\subsection{ViewHolder子类}
	ViewHolder通过itemView域容纳View视图，使用例子如下：
	\begin{lstlisting}
	public class CrimeHolder extends RecyclerView.ViewHolder
	{
		public TextView mTitleTextView;

		public CrimeHolder(View itemView)
		{
			super(itemView);

			mTitleTextView = (TextView)itemView;
		}
	}
	\end{lstlisting}

\subsection{Adapter子类}
	RecyclerView自己不会创建ViewHolder，这个任务交由Adapter子类来完成。\par

	Adapter子类是一个控制器对象，它创建必要的ViewHolder，然后从模型层获取数据，绑定ViewHolder至模型层数据，
	也就是使用模型数据填充视图，然后提供给RecyclerView显示。\par

	当RecyclerView需要新的View视图来显示列表项时，Adapter子类会调用onCreateViewHolder()方法，
	从而创建View视图，然后封装到ViewHolder中。随后Adapter子类再调用onBindViewHolder()方法使用模型数据来填充View视图。\par

	使用例子如下：
	\begin{lstlisting}
	private class CrimeAdapter extends RecyclerView.Adapter<CrimeHolder>
	{
		private List<Crime> mCrimes;

		public CrimeAdapter(List<Crime> crimes)
		{
			mCrimes = crimes;
		}

		@Override
		public CrimeHolder onCreateViewHolder(ViewGroup parent, int viewType)
		{
			LayoutInflater layoutInflater = LayoutInflater.from(getActivity());
			View view = layoutInflater.inflate(android.R.layout.simple_list_item_1, parent, false);
			return new CrimeHolder(view);
		}

		@Override
		public void onBindViewHolder(CrimeHolder holder, int position)
		{
			Crime crime = mCrimes.get(position);
			holder.mTitleTextView.setText(crime.getTitle());
		}

		@Override
		public int getItemCount()
		{
			return mCrimes.size();
		}
	}
	\end{lstlisting}

\subsubsection{notifyDataSetChanged}
	函数声明如下：
	\begin{lstlisting}
	void notifyDataSetChanged()
	\end{lstlisting}

	函数作用：Notifies the attached observers that the underlying data has been changed and any View reflecting the data set should refresh itself.

\subsection{关联Adapter和RecyclerView}
	关联的代码如下：
	\begin{lstlisting}
	public class CrimeListFragment extends Fragment
	{
		private RecyclerView mCrimeRecycleView;
		private CrimeAdapter mAdapter;

		@Override
		public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
		{
			View view = inflater.inflate(R.layout.fragment_crime_list, container, false);
			mCrimeRecycleView = (RecyclerView)view.findViewById(R.id.crime_recycler_view);
			mCrimeRecycleView.setLayoutManager(new LinearLayoutManager(getActivity()));

			CrimeLab crimeLab = CrimeLab.get(getActivity());
			List<Crime> crimes = crimeLab.getCrimes();
			mAdapter = new CrimeAdapter(crimes);
			mCrimeRecycleView.setAdapter(mAdapter);
		}
	}
	\end{lstlisting}

\section{TextView类}
\subsection{setText}
	函数声明如下：
	\begin{lstlisting}
	void setText(int resid);
	\end{lstlisting}

	介绍：Sets the string value of the TextView.


\section{TextWatcher类}
	TextWatcher类有三个方法，如下所示：
	\begin{lstlisting}
	public class TextWatcher
	{
		@Override
		public void beforeTextChanged(CharSequence s, int start, int count, int after)
		{
			// This method is called to notify you that, within s, the count characters beginning at start are about to be replaced by new text with length after.
		}

		@Override
		public void onTextChanged(CharSequence s, int start, int before, int count)
		{
			// This method is called to notify you that, within s, the count characters beginning at start have just replaced old text that had length before.
		}

		@Override
		public void afterTextChanged(Editable s)
		{
			// This method is called to notify you that, somewhere within s, the text has been changed.
		}
	}
	\end{lstlisting}


\section{Toast类}
	Toast类的介绍：A toast is a view containing a quick little message for the user. The toast class helps you create and show those.

\subsection{makeText}
	函数声明如下：
	\begin{lstlisting}
	public static Toast makeText(Context context, int redId, int duration);
	\end{lstlisting}

	该方法用于创建一个toast，第一个Context参数是Activity的一个实例，第二个参数是toast要显示的字符串消息的资源ID，Toast类必须借助Context才能找到并使用字符串的资源ID。
	第三个参数通常是两个Toast常量中的一个，用来指定toast消息显示的持续时间。\par

	makeText函数一般和show()方法配合使用：
	\begin{lstlisting}
	mTrueButton.setOnClickListener(new View.OnClickListener(){
		@Override
		public void onClick(View v)
		{
			Toast.makeText(QuizActivity.this, R.string.incorrect_toast, Toast.LENGTH_SHORT).show();
		}
	});
	\end{lstlisting}

\subsection{show}
	函数声明如下：
	\begin{lstlisting}
	void show();
	\end{lstlisting}

	该方法用于在屏幕上显示toast消息。

\section{ViewPager类}
	ViewPager实现左右滑动屏幕的功能。\par

	Layout manager that allows the user to flip left and right through pages of data. You supply an implementation of a PagerAdapter to generate the pages that the view shows.

\subsection{FragmentStatePagerAdapter类}
	ViewPager对象借助PagerAdapter类来实现划屏切换的功能，我们主要使用PagerAdapter的子类FragmentStatePagerAdapter，
	它有两个虚函数：getCount()用于获得fragment对象的数量，getItem()用于根据所在位置获得相应的frament。\par

	这个类的构造函数如下：
	\begin{lstlisting}
	FragmentStatePagerAdapter(FragmentManager fm);
	\end{lstlisting}

	这个类的使用如下所示：
	\begin{lstlisting}
	public class CrimePagerActivity extends FragmentActivity
	{
		private ViewPager mViewPager;
		private List<Crime> mCrimes;

		@Override
		protected void onCreate(Bundle savedInstanceState)
		{
			super.onCreate(savedInstanceState);
			setContentView(R.layout.activity_crime_pager);

			mViewPager = (ViewPager)findViewById(R.id.activtiy_crime_pager_view_pager);

			mCrimes = CrimeLab.get(this).getCrimes();
			FragmentManager fragmentManager = getSupportFragmentManager();
			mViewPager.setAdapter(new FragmentPagerAdapter(fragmentManager) {
				@Override
				public Fragment getItem(int position) {
					Crime crime = mCrimes.get(position);
					return CrimeFragment.newInstance(crime.getId());
				}

				@Override
				public int getCount()
				{
					return mCrimes.size();
				}
			});
		}
	}
	\end{lstlisting}

\subsection{setAdapter}
	函数声明如下：
	\begin{lstlisting}
	void setAdapter(PagerAdapter adapter);
	\end{lstlisting}

	设置ViewPager对象的PagerAdapter类。

\subsection{setCurrentItem}
	函数声明如下：
	\begin{lstlisting}
	void setCurrentItem(int item);
	\end{lstlisting}

	函数作用：Set the currently selected page. If the ViewPager has already been through its first layout with its current adapter there will be a smooth animated transition between the current item and the specified item.

\end{document}
