% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=bash,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{makefile的语法规则 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{基本语法}
	makefile的基本格式如下所示：
	\begin{lstlisting}
	targets: prerequisites
		command
	\end{lstlisting}

	需要注意的是，command必须以tab键开头。\par
	command也可以和prerequisites在一行，不过要用分号做间隔，如下所示：
	\begin{lstlisting}
	targets: prerequisites; command
	\end{lstlisting}

	如果命令太长，可以使用反斜杠“$\backslash$”。\par

	下面是makefile的一个例子：
	\begin{lstlisting}
	foo.o: foo.c defs.h
		cc -c -g foo.c
	\end{lstlisting}

\section{文件搜寻}
	当工程中存在大量的源文件时，我们需要将源文件分类并存放在不同的目录中。
	makefile通过VPATH变量或vpath关键词告诉make在哪些目录下搜寻文件。

\subsection{VPATH变量}
	使用VPATH变量的格式如下：
	\begin{lstlisting}
	VPATH = dir1:dir2:dir3
	\end{lstlisting}

	可以注意到，目录由冒号“:”间隔。设置上述的VPATH变量后，make首先搜寻当前目录，然后搜寻dir1、dir2和dir3。

\subsection{vpath关键词}
	vpath可以指定在不同的目录中搜索不同的文件，它的使用格式如下：
	\begin{lstlisting}
	# 1.为符合模式<pattern>的文件指定搜索目录<directories>
	vpath <path> <directories>
	# 2.清除符合模式<pattern>的文件的搜索目录
	vpath <pattern>
	# 3.清除所有已被设置好了的文件搜索目录
	vpath
	\end{lstlisting}

	vpath的使用例子如下：
	\begin{lstlisting}
	vpath %.h dir
	\end{lstlisting}

	上述例子中的$\%$可以匹配零个或若干个任意字符，该命令要求make在“dir”目录下搜索所有以“.h”结尾的文件。\par

	vpath还可以设置搜索目录的先后顺序，例子如下：
	\begin{lstlisting}
	vpath %.c dir1
	vpath %.c dir2
	vpath %.c dir3
	\end{lstlisting}

	上述例子先后在“dir1”、“dir2”和“dir3”中搜寻所有以“.c”结尾的文件。\par

	搜寻目录还可以写在一行中，例子如下：
	\begin{lstlisting}
	vpath %.c dir1:dir2:dir3
	\end{lstlisting}

	上述例子先后在“dir1”、“dir2”和“dir3”中搜寻所有以“.c”结尾的文件。

\section{伪目标}
\subsection{基本规则}
	“伪目标”和“目标”不同，make不会为“伪目标”生成一个文件，而是执行伪目标下的命令。
	在makefile中，使用特殊的标记“.PHONY”来指明一个目标是“伪目标”。例子如下：
	\begin{lstlisting}
	.PHONY: clean
	clean:
		rm *.o temp
	\end{lstlisting}

	随后，只要运行“make clean”命令，就可以执行“clean”下的命令。

\subsection{伪目标的依赖文件}
	我们可以为伪目标指定所依赖的文件。因为伪目标总是被执行的，所以它所依赖的文件总是会被决议。
	当多个目标被伪目标依赖时，我们就可以一口气生成多个目标。例子如下：
	\begin{lstlisting}
	all: prog1 prog2 prog3
	.PHONY: all

	prog1: prog1.o utils.o
		cc -o prog1 prog1.o utils.o

	prog2: prog2.o
		cc -o prog2 prog2.o

	prog3: prog3.o sort.o utils.o
		cc -o prog3 prog3.o sort.o utils.o
	\end{lstlisting}

	上述例子中，只要执行“make all”命令，就会自动生成prog1、prog2和prog3这三个目标文件。

\subsection{伪目标作为依赖文件}
	直接看例子：
	\begin{lstlisting}
	.PHONY: cleanall cleanobj cleandiff

	cleanall: cleanobj cleandiff
		rm program

	cleanobj:
		rm *.o

	cleandiff:
		rm *.diff
	\end{lstlisting}

	上述例子中，“cleanobj”和“cleandiff”这两个伪目标类似于子函数。
	这样就可以达到通过输入“make cleanall”、“make cleanobj”和“make cleandiff”命令来清除不同种类文件的目的。

\section{多目标}
	makefile中可能有多个目标依赖于同一个文件，它们的生成命令大体类似。例子如下：
	\begin{lstlisting}
	bigoutput: text.g
		generate text.g -big > bigoutput
	littleoutput: text.g
		generate text.g -little > littleoutput
	\end{lstlisting}

	为了节省代码量，我们可以使用自动化变量“\$@”，例子如下：
	\begin{lstlisting}
	bigoutput littleoutput: text.g
		generate text.g -$(subst output,,$@) > $@
	\end{lstlisting}

	自动化变量“\$@”表示目标的集合，就像一个数组，“\$@”依次取出目标，并用于执行命令。
	“\$(subst output,,\$@)”表示执行makefile中的一个函数，函数名为“subst”，后面的“output,,\$@”为参数，这里的函数用于截取字符串。

\section{静态模式}
	静态模式用于定义生成多目标的规则，语法如下：
	\begin{lstlisting}
	<targets ...>: <target-pattern>: <prereq-patterns ...>
		<commands>
	\end{lstlisting}

	这里介绍一下上述语法的各个组成部分：
	\begin{itemize}
		\item targets。用于定义一系列的目标文件，是目标的一个集合。
		\item target-pattern。用于指明目标文件的字符串模式。
		\item prereq-patterns。用于指明目标文件的依赖文件的字符串模式。
	\end{itemize}

	下面通过一个例子来认识上述语法：
	\begin{lstlisting}
	objects = foo.o bar.o
	all: $(objects)
	$(objects): %.o: %.c
		$(CC) -c $(CFLAGS) $< -o $@
	\end{lstlisting}

	“\%.o”指明了目标文件的字符串模式，也就是任意以“.o”为结尾的文件，
	同时“\%”变为匹配该模式的字符串的集合，也就是“foo bar”。
	随后将“\%”代入依赖文件的字符串模式中，依赖文件就成了“foo.c bar.c”。
	“\$<”表示所有的依赖目标集，“\$@”表示所有的目标集。
	上述例子展开后如下所示：
	\begin{lstlisting}
	foo.o: foo.c
		$(CC) -c $(CFLAGS) foo.c -o foo.o
	bar.o: bar.c
		$(CC) -c $(CFLAGS) bar.c -o bar.o
	\end{lstlisting}

\section{自动生成依赖关系}
	在makefile中，我们需要记录目标文件的每一个依赖文件。
	比如，如果main.c中有一句“\#include "defs.h"”，那么makefile中就要添加下面一行代码：
	\begin{lstlisting}
	main.o: main.c defs.h
	\end{lstlisting}

	C/C++编译器支持一个“-M”的选项，该选项可以找寻源文件中包含的头文件，并生成一个依赖关系。
	命令如下所示：
	\begin{lstlisting}
	cc -M main.c
	\end{lstlisting}

	上述命令的输出为“main.o: main.c defs.h”，编译器将这行命令存放在“main.d”的makefile文件中。
	也就是说，编译器会将每一个源文件的依赖关系存放到“.d”文件中。
	随后将每个“.d”文件包含在主makefile文件中，我们就无需自行记录每个文件的依赖关系了。\par

	可以通过以下命令生成“.d”文件：
	\begin{lstlisting}
	%.d: %.c
	@set -e; rm -f $@; \
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
	sed 's,\($*\)\.o[:]*,\1.o $@: ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$
	\end{lstlisting}

	随后使用“include”命令将这些自动生成的规则放进我们的主makefile中。
	命令如下：
	\begin{lstlisting}
	sources = foo.c bar.c
	include $(sources:.c=.d) # 将$(sources)中所有的“.c”字符串替换为“.d”
	\end{lstlisting}

\end{document}
