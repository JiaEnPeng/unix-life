% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=bash,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{应用层 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

% \tableofcontents

% \clearpage
\section{应用层协议原理}
	网络应用程序有两个例子，一个是web应用程序，另一个是P2P文件共享系统。\par

	web应用程序中包含着浏览器程序和web服务器程序。浏览器程序运行在用户主机上，web服务器程序运行在web服务器主机上。\par

	P2P文件共享系统在参与文件共享的社区中的每台主机中都有一个程序。

\subsection{网络应用程序体系结构}
	网络应用程序体系结构有两种主流的结构，一个是客户-服务器体系结构，还有一个是对等(P2P)体系结构。\par

\subsubsection{客户-服务器体系结构}
	这个结构有两个特征：
	\begin{itemize}
		\item[1.] 有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。
		\item[2.] 该服务器具有固定的、周知的地址，该地址成为IP地址。
	\end{itemize}

\subsubsection{P2P体系结构}
	在一个P2P体系结构中，对位于数据中心的专用服务器有最小的依赖。应用程序在间接连接的主机对之间使用直接通信，这些主机对被称为对等方。
	这种对等方通信不必通过专门的服务器。\par

	P2P体系结构具有自扩展性，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加了服务能力。\par

	P2P体系结构面临着3个主要挑战：
	\begin{itemize}
		\item[1.] ISP友好，P2P应用需要设计对ISP友好的模式。
		\item[2.] 安全性，P2P应用高度分布和开放，所以不安全。
		\item[3.] 激励，只有用户资源自愿向应用提供带宽、存储和计算资源，P2P应用才能成功。
	\end{itemize}

\subsection{进程通信}
	在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。
	发送进程生成并向网络中发送报文，接收进程接收这些报文并可能通过将报文发送回去进行相应。

\subsubsection{客户和服务器进程}
	对每对通信进程，我们通常将这两个进程之一标识为客户，而另一个进程标识为服务器。
	发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。

\subsubsection{进程与计算机网络之间的接口}
	从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为套接字的软件接口向网络发送报文和从网络接收报文。\par

	套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口。

\subsubsection{进程寻址}
	在一台主机上的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。
	为了标识该接收进程，需要定义两种信息：1.主机的地址；2.定义在目的主机中的接收进程的标识符。\par

	在因特网中，主机地址由IP地址标识。\par

	目的地端口号用于定义在目的主机中的接收进程，比如说Web服务器用端口号80来标识。

\subsection{可供应用程序使用的运输服务}
	一个运输层协议必须为它的应用程序提供四种服务：可靠数据传输、吞吐量、定时和安全性。

\subsubsection{可靠数据传输}
	运输层确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端。
	如果应用层协议提供了这样的确保数据交付服务，就认为提供了可靠数据传输。

\subsubsection{吞吐量}
	可用吞吐量就是发送进程能够向接收进程交付比特的速率。运输层协议能够以某种特定的速率提供确保的可用吞吐量。

\subsubsection{定时}
	运输层协议能够提供定时保证，比如发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。

\subsubsection{安全性}
	运输层协议能够为应用程序提供一种或多种安全性服务。
	比如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够在数据交付给接收进城之前解密这些数据。

\subsection{因特网提供的运输服务}
	因特网为应用程序提供两个运输层协议，即UDP和TCP。

\subsubsection{TCP服务}
	当应用程序调用TCP作为其运输协议时，TCP将提供两种服务：
	\begin{itemize}
		\item[1.] 面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器经历一个握手过程，互相交换运输层控制信息。在握手过程之后，一个TCP连接就在两个进程的套接字之间建立了。
		\item[2.] 可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。
	\end{itemize}

	TCP还有拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程。

\subsubsection{UDP服务}
	UDP服务没有握手过程，也没有UDP连接，没有拥塞控制机制，仅提供最小服务。\par

	当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程，而且到达接收进程的报文也可能是乱序到达的。

\subsection{应用层协议}
	应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。应用层协议定义了如下内容：
	\begin{itemize}
		\item[1.] 交换的报文类型，例如请求报文和响应报文。
		\item[2.] 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。
		\item[3.] 字段的语义，即这些字段中包含的信息的含义。
		\item[4.] 一个进程何时以及如何发送报文，对报文进行响应的规则。
	\end{itemize}

\section{Web和HTTP}
\subsection{HTTP概况}
	Web应用的应用层协议是HTTP，也就是超文本传输协议。\par

	web客户程序和web服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。
	HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。

\subsubsection{一些web术语}
	一个Web页面是由对象组成的，一个对象就是一个文件，通过URL地址寻址得到。\par

	每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。
	比如，URL地址为http://www.someSchool.edu/someDepartment/picture.gif，其中www.someSchool.edu是主机名，/someDepartment/picture.gif是路径名。\par

	web浏览器实现了HTTP的客户端，web服务器实现了HTTP的服务器端，它用于存储web对象，每个对象由URL寻址。

\subsubsection{HTTP的作用}
	HTTP定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式。\par

	HTTP使用TCP作为它的支撑运输协议，HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。
	客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文，服务器从它的套接字接口接收HTTP请求报文并从它的套接字接口发送HTTP响应报文。

\subsubsection{无状态协议}
	HTTP服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以我们说HTTP是一个无状态协议。\par

	假如某个特定的客户在短短的几秒钟内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。

\subsection{请求html文件的时间}
	在这里将估算一下从客户请求HTML基本文件起到该客户收到整个文件止所花费的时间。\par

	首先定义往返时间RTT：一个短分组从客户机到服务器然后再返回客户所花费的时间。
	RTT包括分组传输时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。\par

	HTTP客户向HTTP请求HTML文件时，需要发起TCP连接，然后请求文件，最后服务器发送HTML文件。发起TCP连接和请求文件各占一个RTT时间，
	所以总的时间为两个RTT加上服务器传输HTML文件的时间。

\subsection{非持续连接和持续连接}
	在客户和服务器相互通信的过程中，客户发出一系列请求并且服务器对每个请求进行响应。
	对于非持续连接的HTTP，每个请求-响应对经过一个单独的TCP连接发送。
	而对于持续连接的HTTP，所有请求-响应对都经过相同的TCP连接发送。

\subsubsection{非持续连接的HTTP}
	HTTP客户向HTTP服务器请求一个web页面，该web页面包含一个html文件和10个jpeg图形，该html文件的url为：http://www.someSchool.edu/someDepartment/home.index。
	步骤如下：
	\begin{itemize}
		\item[1.] HTTP客户进程在端口号80发起一个到服务器www.someSchool.edu的TCP连接，随后在客户和服务器上分别有一个套接字与该连接相关联。
		\item[2.] HTTP客户经它的套接字向服务器发送一个HTTP请求报文，其中包含html文件的路径/someDepartment/home.index。
		\item[3.] HTTP服务器进程经它的套接字接收该请求报文，根据路径名得到html文件。在一个http响应报文中封装对象，并通过套接字向客户发送响应报文。
		\item[4.] HTTP服务器进程通知TCP断开该TCP连接。
		\item[5.] HTTP客户接收响应报文，TCP连接关闭。客户从响应报文中提取出该文件，检查该html文件，得到对10个jpeg图形的引用。
		\item[6.] 对每个引用的jpeg图形对象重复前4个步骤。
	\end{itemize}

	非持续连接的缺点为：
	\begin{itemize}
		\item[1.] 必须为每一个请求的对象建立和维护一个全新的连接。
		\item[2.] 每一个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。
	\end{itemize}

\subsubsection{持续连接的HTTP}
	在采用持续连接的情况下，服务器在发送响应后保持该TCP连接打开。
	在相同的客户与服务器之间的后续请求和响应报文能够通过相同的TCP连接进行传送。

\subsection{HTTP报文格式}
	HTTP报文有两种：请求报文和响应报文。

\subsubsection{HTTP请求报文}
	一个典型的HTTP请求报文：
	\begin{lstlisting}
	GET /somedir/page.html HTTP/1.1\r\n
	Host: www.someschool.edu\r\n
	Connection: close\r\n
	User-agent: Mozilla/5.0\r\n
	Accept-language: fr\r\n
	\r\n
	\end{lstlisting}

	HTTP请求报文的第一行叫做请求行，后继的行叫做首部行：
	\begin{itemize}
		\item 请求行有3个字段：方法字段、URL字段和HTTP版本字段。方法字段有：GET、POST、HEAD、PUT和DELETE。
		\item 首部行中，Host用于指定对象所在的主机，Connection用于指定这条连接在请求响应结束后是否关闭，User-agent用于指定浏览器的类型，Accept-language用于指定对象的哪个语言版本。
	\end{itemize}

	各个方法：
	\begin{itemize}
		\item POST，将使用一个“entity body”。使用POST报文时，用户可以向服务器请求一个web页面，这个web页面的特定内容依赖于用户在表单字段中输入的内容。entity body中包含的就是用户在表单字段中的输入值。
		\item GET，此时entity body为空。不过HTML表单也经常使用GET方法，它会在所请求的URL中包含输入的数据。
		\item HEAD，类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。
		\item PUT，允许用户上传对象到指定的web服务器上指定的路径。
		\item DELETE，允许用户或者应用程序删除web服务器上的对象。
	\end{itemize}

\subsubsection{HTTP响应报文}
	一个典型的HTTP响应报文：
	\begin{lstlisting}
	HTTP/1.1 200 OK\r\n
	Connection: close\r\n
	Data: Tue, 09 Aug 2011 15:44:04 GMT\r\n
	Server: Apache/2.2.3(CentOS)\r\n
	Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT\r\n
	Content-length: 6821\r\n
	Content-Type: text/html\r\n
	\r\n
	(data data data data data ...)
	\end{lstlisting}

	响应报文的第一行为状态行，还有6个首部行，最后是entity body：
	\begin{itemize}
		\item 状态行，包含协议版本字段、状态码和相应状态信息。
		\item 首部行中，Connection：close告诉客户发送完报文后关闭该TCP连接，Data用于指示服务器产生并发送该响应报文的日期和时间。
			  Server用于指定服务器类型，Last-Modified用于指定对象创建或最后修改的日期和时间，Content-Length用于指定发送对象的字节数，
			  Content-Type：用于指定entity body中的对象类型。
	\end{itemize}

	一些常见的状态码和相应状态信息：
	\begin{itemize}
		\item 200 OK：请求成功。
		\item 301 Moved Permanently：请求的对象已经被永久转移了。新的URL定义在响应报文的Location中。
		\item 400 Bad Request：一个通用差错代码。
		\item 404 Not Found：被请求的文档不在服务器上。
		\item 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。
	\end{itemize}

\subsection{用户与服务器的交互}
	cookie技术有4个组件：
	\begin{itemize}
		\item HTTP响应报文中的一个Set-cookie首部行。
		\item HTTP请求报文中的一个Cookie首部行。
		\item 在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理。
		\item 在服务器端有一个后端数据库。
	\end{itemize}

	课本的第72～73页有一个生动的例子。

\subsection{Web缓存器}
	Web缓存器也叫代理服务器，它是能够代表初始化Web服务器来满足HTTP请求的网络实体。\par

	Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。
	可以配置浏览器，使得HTTP请求首先指向web缓存器。如果web缓存器没有该对象，web缓存器会向初始服务器请求对象，然后存储一份副本，并向客户发送该副本。\par

	Web缓存器的优点：
	\begin{itemize}
		\item web缓存器可以大大减少对客户请求的响应时间。
		\item web缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构就不必急于增加带宽，因此降低了费用。
	\end{itemize}

	课本的第75页通过一个例子介绍了web缓存器的优点。

\subsection{条件GET方法}
	条件GET方法可以让缓存器证实它的对象是最新的，条件GET方法要求：
	\begin{itemize}
		\item 请求报文使用GET方法。
		\item 请求报文中包含一个“If-Modified-Since”的首部行。
	\end{itemize}

	课本的第76～77页有一个例子介绍了这个方法的使用。

\section{文件传输协议：FTP}
	FTP的步骤如下：
	\begin{itemize}
		\item[1.] 用户首先提供远程主机的主机名，使本地主机的FTP客户进程建立一个到远程主机的FTP服务器进程的TCP连接。
		\item[2.] 该用户接着提供用户标识和口令，作为FTP命令的一部分在该TCP连接上传送。
		\item[3.] 一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者多个文件复制到远程文件系统。
	\end{itemize}

	FTP使用了两个并行的TCP连接：
	\begin{itemize}
		\item 控制连接，用于在两主机之间传输控制信息。
		\item 数据连接，用于实际发送一个文件。
	\end{itemize}

	因为FTP使用一个独立的控制连接，所以FTP的控制信息是带外的。而HTTP协议在同一个TCP连接中发送请求和响应首部行，所以是带内的。\par

	FTP服务器必须在整个会话期间保留用户的状态，也就是对每个进行中的用户会话的状态信息进行追踪。

\subsection{FTP命令和回答}
	一些较为常见的命令如下：
	\begin{itemize}
		\item USER username，用于向服务器传送用户标识。
		\item PASS password，用于向服务器发送用户口令。
		\item LIST，用于请求服务器回送当前远程目录中的所有文件列表。
		\item RETR filename，用于从远程主机当前目录获取文件。
		\item STOR filename，用于在远程主机的当前目录存放文件。
	\end{itemize}

	一些典型的回答如下：
	\begin{itemize}
		\item 331 Username OK, Password required
		\item 125 Data connection already open; transfer starting
		\item 425 Can't open data connection
		\item 452 Error writing file
	\end{itemize}

\section{因特网中的电子邮件}
	因特网电子邮件系统的3个主要组成部分：用户代理、邮件服务器和简单邮件传输协议。\par

	一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，在传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。

\subsection{简单邮件传输协议SMTP}
	SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。\par

	SMTP的工作过程：SMTP客户端发现发送方邮件服务器中报文队列中的这个报文，然后创建一个到接收方邮件服务器上的SMTP服务器的TCP连接。经过一些初始SMTP握手后，SMTP客户通过该TCP连接发送报文。
	在接收方邮件服务器上，SMTP的服务器端接收该报文。在握手阶段，SMTP客户端会指示发送方的邮件地址和接收方的邮件地址。\par

	SMTP不使用中间邮件服务器发送邮件。\par

	SMTP有一些常用的命令：HELO、MAIL FROM、RCPT TO、DATA以及QUIT。在课本的第82页有一个SMTP工作的例子。\par

	对于每个报文，客户通过MAIL FROM开始，用一个独立的句点“.”指示该邮件的结束，并且仅当所有邮件发送完后才发送QUIT。

\subsection{邮件报文格式}
	一个邮件报文由首部、空行和报文体组成。\par

	每个首部必须含有一个From，一个To，有时候还可能包含一个Subject。一个典型的报文首部如下：
	\begin{lstlisting}
	From: alice@crepes.fr
	To: bob@hamburger.edu
	Subject: Searching for the meaning of life
	\end{lstlisting}

\subsection{邮件访问协议}
	我们通过邮局访问协议将邮件服务器上的报文传送回本地PC。流行的邮件访问协议有：第三版的邮局协议POP3、因特网邮件访问协议IMAP以及HTTP。

\subsubsection{POP3}
	POP3按照三个阶段进行工作：
	\begin{itemize}
		\item 特许阶段，用户代理发送用户名和口令来鉴别用户。
		\item 事务处理阶段，用户代理取回报文，同时用户代理还能对报文做删除标记、取消报文删除标记，以及获取邮件的统计信息。
		\item 更新阶段，在客户发出quit命令后开始，目的是结束该POP3会话。此时，邮件服务器删除那些被标记为删除的报文。
	\end{itemize}

	服务器对用户代理的命令有两种：
	\begin{itemize}
		\item +OK，指示命令正常。
		\item -ERR，指示命令出现了某些差错。
	\end{itemize}

	特许阶段有两个命令：user <username>和pass <password>，例子如下：
	\begin{lstlisting}
	telnet mailServer 110
	user bob
	pass hungry
	\end{lstlisting}

	事务处理阶段有四个命令：list、retr、dele和quit。

\subsubsection{IMAP}
	IMAP的两个重要特性：
	\begin{itemize}
		\item[1.] IMAP服务器把每个报文与一个文件夹联系起来，并且维护了IMAP会话的用户状态信息。
		\item[2.] IMAP允许用户代理获取报文组件的命令，也就是说，一个用户代理可以只读区一个报文的报文首部，或只是一个多部分MIME报文的一部分。
	\end{itemize}

\end{document}
