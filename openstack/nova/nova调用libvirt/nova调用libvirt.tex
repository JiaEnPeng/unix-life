% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=1.5cm,right=1.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{etoolbox}%
\makeatletter
\patchcmd{\ttlh@hang}{\parindent\z@}{\parindent\z@\leavevmode}{}{}%
\patchcmd{\ttlh@hang}{\noindent}{}{}{}%
\makeatother

\usepackage{longtable}
\usepackage{empheq}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
%\titleformat*{\section}{\LARGE}
%\renewcommand\refname{参考文献}
%\titleformat{\chapter}{\centering\bfseries\huge}{}{0.7em}{}{}
\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{ \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXINGKA.TTF}
%\setCJKfamilyfont{cjkhwxk}{华文行楷}
%\setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
%\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
%\newfontfamily\wryh{Microsoft YaHei}
%\newfontfamily\hwzs{华文中宋}
%\newfontfamily\hwst{华文宋体}
%\newfontfamily\hwfs{华文仿宋}
%\newfontfamily\jljt{方正静蕾简体}
%\newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=python,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

%\newfontfamily{\consolas}{Consolas}
%\newfontfamily{\monaco}{Monaco}
%\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
%\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
%\setmainfont{Times New Roman}
%\setCJKmainfont{STZHONGS.TTF}
%\setmonofont{Consolas}
% \newfontfamily{\consolas}{YaHeiConsolas.ttf}
\newfontfamily{\monaco}{MONACO.TTF}
\setCJKmainfont{STZHONGS.TTF}
%\setmainfont{MONACO.TTF}
%\setsansfont{MONACO.TTF}

\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

\newcommand{\tablestart}{
	\interval
	\begin{longtable}{p{2cm}p{10cm}}
	\hline}
\newcommand{\tableend}{
	\hline
	\end{longtable}
	\interval}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{nova调用libvirt \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}

\begin{document}

\tableofcontents

\clearpage

\section{前言}
	在nova/virt/libvirt/driver.py中有LibvirtDriver类，用于调用libvirt。

\section{nova创建虚拟机时对libvirt的调用}
	LibvirtDriver类中创建虚拟机的函数代码如下：
	\begin{lstlisting}
	def spawn(self, context, instance, image_meta, injected_files,
              admin_password, network_info=None, block_device_info=None):

        ...

		# 创建镜像
		# disk_info是一个字典，格式如下：
		# {'disk_bus': disk_bus,     the bus for harddisks
        #  'cdrom_bus': cdrom_bus,   the bus for CDROMs
        #  'mapping': mapping}       the disk mapping
        self._create_image(context, instance, disk_info['mapping'],
                           injection_info=injection_info,
                           block_device_info=block_device_info)

        ...

		# 创建xml配置文件
        xml = self._get_guest_xml(context, instance, network_info,
                                  disk_info, image_meta,
                                  block_device_info=block_device_info)

		...

		# 创建虚拟机和网络
        self._create_domain_and_network(
            context, xml, instance, network_info, disk_info,
            block_device_info=block_device_info,
            post_xml_callback=gen_confdrive,
            destroy_disks_on_failure=True)
	\end{lstlisting}

\clearpage

\subsection{创建镜像}
	相关语句与函数如下：
	\begin{lstlisting}
	self._create_image(context, instance, disk_info['mapping'],
                           injection_info=injection_info,
                           block_device_info=block_device_info)

	# _create_image函数如下
	def _create_image(self, context, instance,
                      disk_mapping, suffix='',
                      disk_images=None, network_info=None,
                      block_device_info=None, files=None,
                      admin_pass=None, inject_files=True):
        booted_from_volume = self._is_booted_from_volume(
            instance, disk_mapping)

        def image(fname, image_type=CONF.libvirt.images_type):
            return self.image_backend.image(instance,
                                            fname + suffix, image_type)

        def raw(fname):
            return image(fname, image_type='raw')

        # 创建instance目录，用来存放镜像和libvirt.xml配置文件
		# 调用os.makedirs(path)创建目录
        fileutils.ensure_tree(libvirt_utils.get_instance_path(instance))

        ...

		# 如果disk_images为None，就创建一个disk_images字典
        if not disk_images:
            disk_images = {'image_id': instance['image_ref'],
                           'kernel_id': instance['kernel_id'],
                           'ramdisk_id': instance['ramdisk_id']}

		# 如果kernel、ramdisk存在就跳过
		# 如果不存在将调用nova.image.glance.GlanceImageService.download()函数下载image
        if disk_images['kernel_id']:
            fname = imagecache.get_cache_fname(disk_images, 'kernel_id')
            raw('kernel').cache(fetch_func=libvirt_utils.fetch_image,
                                context=context,
                                filename=fname,
                                image_id=disk_images['kernel_id'],
                                user_id=instance['user_id'],
                                project_id=instance['project_id'])
            if disk_images['ramdisk_id']:
                fname = imagecache.get_cache_fname(disk_images, 'ramdisk_id')
                raw('ramdisk').cache(fetch_func=libvirt_utils.fetch_image,
                                     context=context,
                                     filename=fname,
                                     image_id=disk_images['ramdisk_id'],
                                     user_id=instance['user_id'],
                                     project_id=instance['project_id'])

        inst_type = flavors.extract_flavor(instance)
        
		# 如果后端镜像存在就跳过
		# 如果不存在但支持拷贝，就掉用Image.clone()拷贝后端镜像
		# 否则调用nova.image.glance.GlanceImageService.download()函数下载后端镜像
        if not booted_from_volume:
            root_fname = imagecache.get_cache_fname(disk_images, 'image_id')
            size = instance['root_gb'] * units.Gi

            if size == 0 or suffix == '.rescue':
                size = None

            backend = image('disk')
            if backend.SUPPORTS_CLONE:
                def clone_fallback_to_fetch(*args, **kwargs):
                    try:
                        backend.clone(context, disk_images['image_id'])
                    except exception.ImageUnacceptable:
                        libvirt_utils.fetch_image(*args, **kwargs)
                fetch_func = clone_fallback_to_fetch
            else:
                fetch_func = libvirt_utils.fetch_image

            backend.cache(fetch_func=fetch_func,
                          context=context,
                          filename=root_fname,
                          size=size,
                          image_id=disk_images['image_id'],
                          user_id=instance['user_id'],
                          project_id=instance['project_id'])

        # Lookup the filesystem type if required
        os_type_with_default = disk.get_fs_type_for_os_type(
                                                          instance['os_type'])
		
		# 如果ephemeral分区存在就跳过
		# 否则调用nova.utils.mkfs()创建分区
        ephemeral_gb = instance['ephemeral_gb']
        if 'disk.local' in disk_mapping:
            disk_image = image('disk.local')
            fn = functools.partial(self._create_ephemeral,
                                   fs_label='ephemeral0',
                                   os_type=instance["os_type"],
                                   is_block_dev=disk_image.is_block_dev)
            fname = "ephemeral_%s_%s" % (ephemeral_gb, os_type_with_default)
            size = ephemeral_gb * units.Gi
            disk_image.cache(fetch_func=fn,
                             context=context,
                             filename=fname,
                             size=size,
                             ephemeral_size=ephemeral_gb)

        for idx, eph in enumerate(driver.block_device_info_get_ephemerals(
                block_device_info)):
            disk_image = image(blockinfo.get_eph_disk(idx))

            specified_fs = eph.get('guest_format')
            if specified_fs and not self.is_supported_fs_format(specified_fs):
                msg = _("%s format is not supported") % specified_fs
                raise exception.InvalidBDMFormat(details=msg)

            fn = functools.partial(self._create_ephemeral,
                                   fs_label='ephemeral%d' % idx,
                                   os_type=instance["os_type"],
                                   is_block_dev=disk_image.is_block_dev)
            size = eph['size'] * units.Gi
            fname = "ephemeral_%s_%s" % (eph['size'], os_type_with_default)
            disk_image.cache(fetch_func=fn,
                             context=context,
                             filename=fname,
                             size=size,
                             ephemeral_size=eph['size'],
                             specified_fs=specified_fs)
		
		# 如果swap分区存在就跳过
		# 否则调用nova.utils.mkfs()创建分区
        if 'disk.swap' in disk_mapping:
            mapping = disk_mapping['disk.swap']
            swap_mb = 0

            swap = driver.block_device_info_get_swap(block_device_info)
            if driver.swap_is_usable(swap):
                swap_mb = swap['swap_size']
            elif (inst_type['swap'] > 0 and
                  not block_device.volume_in_mapping(
                    mapping['dev'], block_device_info)):
                swap_mb = inst_type['swap']

            if swap_mb > 0:
                size = swap_mb * units.Mi
                image('disk.swap').cache(fetch_func=self._create_swap,
                                         context=context,
                                         filename="swap_%s" % swap_mb,
                                         size=size,
                                         swap_mb=swap_mb)

        ...
	\end{lstlisting}

\subsection{创建xml配置文件}
	相关语句与函数如下：
	\begin{lstlisting}
	xml = self._get_guest_xml(context, instance, network_info,
                                  disk_info, image_meta,
                                  block_device_info=block_device_info)
	
	# _get_guest_xml()函数如下
	def _get_guest_xml(self, context, instance, network_info, disk_info,
                       image_meta=None, rescue=None,
                       block_device_info=None, write_to_disk=False):
        ...
		# 根据instance的配置创建一个nova.virt.libvirt.LibvirtConfigObject类
        conf = self._get_guest_config(instance, network_info, image_meta,
                                      disk_info, rescue, block_device_info,
                                      context)
		# 获得虚拟机的xml文件
        xml = conf.to_xml()

        if write_to_disk:
			# 创建libvirt.xml文件
            instance_dir = libvirt_utils.get_instance_path(instance)
            xml_path = os.path.join(instance_dir, 'libvirt.xml')
            libvirt_utils.write_to_file(xml_path, xml)

        ...
        return xml
	\end{lstlisting}

\subsection{创建虚拟机的函数}
	LibvirtDriver类中调用libvirt创建虚拟机和网络的函数代码如下，因为我更关注创建虚拟机的流程，所以把与创建网络有关的代码略去：
	\begin{lstlisting}
	def _create_domain_and_network(self, context, xml, instance, network_info,
                                   disk_info, block_device_info=None,
                                   power_on=True, reboot=False,
                                   vifs_already_plugged=False,
                                   post_xml_callback=None,
                                   destroy_disks_on_failure=False):

        ...

		# 创建虚拟机
        guest = None
        try:
            with self.virtapi.wait_for_instance_event(
                    instance, events, deadline=timeout,
                    error_callback=self._neutron_failed_callback):
                ...
                with self._lxc_disk_handler(instance, instance.image_meta,
                                            block_device_info, disk_info):
                    guest = self._create_domain(
                        xml, pause=pause, power_on=power_on,
                        post_xml_callback=post_xml_callback)
					...
        ...

        return guest
	\end{lstlisting}

	创建虚拟机的函数代码如下：
	\begin{lstlisting}
	def _create_domain(self, xml=None, domain=None,
                       power_on=True, pause=False, post_xml_callback=None):
		
		# 创建虚拟机
		# 这里的libvirt_guest在driver.py中有引用：from nova.virt.libvirt import guest as libvirt_guest
        if xml:
            guest = libvirt_guest.Guest.create(xml, self._host)
        else:
            guest = libvirt_guest.Guest(domain)

        ...

        return guest
	\end{lstlisting}

	从上面的代码可以看出，nova/virt/libvirt/guest.py中的Guest类就是对虚拟机instance的抽象。\par

	因为我们这里是新建虚拟机，所以domain应该是None，是调用Guest.create()函数来创建虚拟机。
	下面来看Guest类的create()函数：
	\begin{lstlisting}
class Guest(object):
	@classmethod
    def create(cls, xml, host):
        
        try:
            ...
			# 这里使用host创建虚拟机，host是nova/virt/libvirt/host.py中的Host类
            guest = host.write_instance_config(xml)
        
		...

        return guest
	\end{lstlisting}

	这里的Host类的write\_instance\_config()的代码如下所示：
	\begin{lstlisting}
	def write_instance_config(self, xml):
		# 直接告诉我们，get_connection()函数返回的是与libvirt相关的对象
		# 下面这行代码可以让我们想起：virsh define demo.xml这个命令
		# 实际上self.get_connection()返回的是一个virConnect对象
        domain = self.get_connection().defineXML(xml)

        return libvirt_guest.Guest(domain)
	\end{lstlisting}

	如果想知道openstack怎么创建一个virConnect对象，就继续看get\_connection()函数：
	\begin{lstlisting}
	def get_connection(self):
        
        try:
			# 很清楚地看到conn对象是由_get_connection()创建的
            conn = self._get_connection()
        
		...

        return conn
	\end{lstlisting}

	进一步看\_get\_connection()函数：
	\begin{lstlisting}
	def _get_connection(self):
		# _wrapped_conn_lock是一个互斥锁
        with self._wrapped_conn_lock:
			...
			# _wrapped_conn是一个连接到libvirt的对象
            # 当前服务没有调用libvirt是，_wrapped_conn是None
            if self._wrapped_conn is None:
                try:
                    # 连接到libvirt并返回一个对象
                    self._wrapped_conn = self._get_new_connection()
                
				...

        return self._wrapped_conn
	\end{lstlisting}

	再来看\_get\_new\_connection()函数：
	\begin{lstlisting}
	def _get_new_connection(self):
        ...
		# 这里的uri是'qemu:///system'，根据之前的代码追踪过程可以轻易得知，在此不再详述如何追踪到它的值
		# _read_only为False
		# 使用_connect()函数创建wrapped_conn对象
		# 如果熟悉libvirt API，那么看到这条语句会想到下面C语言中的这条语句：
		#	conn = virConnectPtr("qemu:///system")
		#	conn是virConnectPtr对象，python中是virConnect类
        wrapped_conn = self._connect(self._uri, self._read_only)

        ...

        return wrapped_conn
	\end{lstlisting}

	分析到这，应该算是比较清楚了。我们如果是熟悉Libvrit API，那么就能使用libvirt的API在openstack中呼风唤雨了。\par

\clearpage

\section{nova扩容时对libvirt的调用}
\subsection{nova扩容的流程介绍}
	流程如下：
	\begin{itemize}
		\item[1.] 首先，目的主机调用compute.ComputeManager.prep\_resize()函数进行扩容前的准备。
				  随后通过RPC通信，让源主机调用resize\_instance()函数。
				  因为prep\_resize()函数与libvirt API的调用关系较小，在此不做分析。
		\item[2.] 源主机通过compute.ComputeManager.resize\_instance()函数实现了将虚拟机的增量文件迁移到目的主机上。
			      随后通过RPC通信，让目的主机调用finish\_resize()函数。
		\item[3.] 目的主机通过compute.ComputeManager.finish\_resize()函数实现了一些后续操作。
	\end{itemize}

	上面这个流程说得比较简略，而且也略去了compute-api、compute-conductor和compute-scheduler这三个服务的操作。
	如果想要详细了解这个过程，可以看《resize虚拟机的流程》这篇文章。\par

	接下来，我只会从LibvirtDriver类中实现以上功能的函数开始分析。

\subsection{源主机上的操作}
	LibvirtDriver类中实现resize\_instance()功能的函数是migrate\_disk\_and\_power\_off()。\par

	在看这个函数之前，我们需要一些预备知识。

\subsubsection{预备知识：虚拟机的后端镜像和增量镜像}
	在物理机的磁盘上，openstack使用后端镜像和增量镜像创建虚拟机，如下图所示：
	\fic{4.png}

	后端镜像(base镜像)是虚拟机的原始镜像文件，可以说是虚拟机创建时产生的镜像文件。它的格式可以是raw或qcow2，
	在恒天云的环境中是raw格式。\par

	增量镜像又叫做copy-on-write镜像，由于记录与原始镜像文件的不同内容。
	增量镜像虽然是一个单独的文件，但它的大部分数据都来自于原始镜像，只有跟原始镜像文件相比有变化的cluster才会被记录下来。
	增量镜像的格式必须是qcow2.。\par

	如果目的主机和源主机的base镜像相同，那么只需要迁移增量镜像，就可以在目的主机上使用相同的虚拟机。\par

	如果目的主机上没有相同的base镜像，还需要传输base镜像。

\subsubsection{migrate\_disk\_and\_power\_off函数}

	\begin{lstlisting}
	# nova/virt/libvirt/driver.py LibvirtDriver.migrate_disk_and_power_off()
	def migrate_disk_and_power_off(self, context, instance, dest,
                                   flavor, network_info,
                                   block_device_info=None,
                                   timeout=0, retry_interval=0):
		# block_device_info是一个字典，如下所示：
		# {'swap': swap,
		# 'root_device_name': root_device_name,
		# 'ephemerals': ephemerals,
		# 'block_device_mapping': block_device_mapping}
		# 
		# disk_info_text数据类型是一个list，里面有多个字典，字典格式如下
		# {'type': disk_type,
		# 'path': path,
		# 'virt_disk_size': virt_size,
		# 'backing_file': backing_file,
		# 'disk_size': dk_size,
		# 'over_committed_disk_size': over_commit_size}
		# 获取disk配置信息
        disk_info_text = self.get_instance_disk_info(instance['name'],
                block_device_info=block_device_info)

		# 调用json.loads()
		disk_info = jsonutils.loads(disk_info_text)

		# 调用os.path.join(CONF.instances_path, instance['name'])获得inst_base
		# inst_base存放着虚拟机的增量镜像
		# inst_base格式为/var/lib/nova/instances/vm-uuid
        inst_base = libvirt_utils.get_instance_path(instance)
		# 创建resize以后instance增量镜像的存放路径
        inst_base_resize = inst_base + "_resize"

		# 判断是否共用storage
		# 有可能目的主机和源主机本身就是同一台
		# 也有可能目的主机和源主机共享存储
        shared_storage = self._is_storage_shared_with(dest, inst_base)

		# 如果不是共享storage，就需要迁移增量镜像
		# 在目的主机下根据inst_base创建增量镜像的文件夹
        if not shared_storage:
            utils.execute('ssh', dest, 'mkdir', '-p', inst_base)

		# 关闭虚拟机，这个函数稍后分析
        self.power_off(instance, timeout, retry_interval)

		...

        try:
			# 重命名inst_base为inst_base_resize
			# 也就是将源主机上虚拟机增量文件所在目录名加上“_resize”
            utils.execute('mv', inst_base, inst_base_resize)

			# 如果共享storage，说明之后还需要将文件拷贝到原来的目录下
			# 所以下面需要再创建原目录
            if shared_storage:
                dest = None
                utils.execute('mkdir', '-p', inst_base)

            active_flavor = flavors.extract_flavor(instance)

			# 迁移虚拟机磁盘内容
            for info in disk_info:
				# 得到增量文件的路径
				# img_path格式为/var/lib/nova/instances/vm-uuid/fname
                img_path = info['path']
				# 得到增量文件的文件名
                fname = os.path.basename(img_path)
				# 创建源主机下增量文件的文件名
                from_path = os.path.join(inst_base_resize, fname)

				# 如果文件是“disk.swap”，那么就不迁移
                if (fname == 'disk.swap' and
                    active_flavor.get('swap', 0) != flavor.get('swap', 0)):
                    continue
				
				# 这两个匿名函数用于之后的rsync ssh拷贝文件
                on_execute = lambda process: self.job_tracker.add_job(
                    instance, process.pid)
                on_completion = lambda process: self.job_tracker.remove_job(
                    instance, process.pid)

				# 如果类型是qcow2并且有后端镜像，就把扩容后的后端文件和增量文件合并
				# 合并后的文件存放在tmp_path中
				# tmp_path格式为/var/lib/nova/instances/vm-uuid_resize/fname_rbase
                if info['type'] == 'qcow2' and info['backing_file']:
                    tmp_path = from_path + "_rbase"
                    # 通过“qemu-img convert”命令将虚拟机的后端镜像和增量镜像合并
                    utils.execute('qemu-img', 'convert', '-f', 'qcow2',
                                  '-O', 'qcow2', from_path, tmp_path)

                    if shared_storage:
						# 如果共享storage，此时只要重命名文件
						# 相当于将文件又移到了/var/lib/nova/instances/vm-uuid/fname
                        utils.execute('mv', tmp_path, img_path)
                    else:
						# 如果是不同主机，那么需要调用如下函数，稍后分析
                        libvirt_utils.copy_image(tmp_path, img_path, host=dest,
                                                 on_execute=on_execute,
                                                 on_completion=on_completion)
                        utils.execute('rm', '-f', tmp_path)

				# 如果类型是raw或者是没有后端镜像的qcow2，就可以直接转移
                else:
                    libvirt_utils.copy_image(from_path, img_path, host=dest,
                                             on_execute=on_execute,
                                             on_completion=on_completion)
        ...
	\end{lstlisting}

\subsubsection{关闭虚拟机}
	相关语句如下：
	\begin{lstlisting}
	self.power_off(instance, timeout, retry_interval)
	\end{lstlisting}

	这个函数如下所示：
	\begin{lstlisting}
	def power_off(self, instance, timeout=0, retry_interval=0):
        if timeout:
            self._clean_shutdown(instance, timeout, retry_interval)
        self._destroy(instance)
	\end{lstlisting}

	继续追踪\_destroy()函数：
	\begin{lstlisting}
	def _destroy(self, instance):
        try:
			# 根据virConnect.lookupByName()获得virDomain对象
            virt_dom = self._lookup_by_name(instance['name'])
        ...

        
        old_domid = -1
        if virt_dom is not None:
            try:
                old_domid = virt_dom.ID()
				# 调用virtDomain.destroy()函数关闭虚拟机
                virt_dom.destroy()
            ...
		
		# 接下来的代码都是用于判断虚拟机是否真正关机
        def _wait_for_destroy(expected_domid):
            try:
                dom_info = self.get_info(instance)
                state = dom_info['state']
                new_domid = dom_info['id']
            except exception.InstanceNotFound:
                LOG.warning(_LW("During wait destroy, instance disappeared."),
                            instance=instance)
                raise loopingcall.LoopingCallDone()

            if state == power_state.SHUTDOWN:
                LOG.info(_LI("Instance destroyed successfully."),
                         instance=instance)
                raise loopingcall.LoopingCallDone()

            if new_domid != expected_domid:
                LOG.info(_LI("Instance may be started again."),
                         instance=instance)
                kwargs['is_running'] = True
                raise loopingcall.LoopingCallDone()

        kwargs = {'is_running': False}
        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_destroy,
                                                     old_domid)
        timer.start(interval=0.5).wait()
        if kwargs['is_running']:
            LOG.info(_LI("Going to destroy instance again."),
                     instance=instance)
            self._destroy(instance)
	\end{lstlisting}

\clearpage

\subsubsection{迁移镜像文件}
	相关语句如下：
	\begin{lstlisting}
	# info是一个字典，如下所示：
	# {'type': disk_type,
	# 'path': path, path的格式为/var/lib/nova/instances/vm-uuid/
	# 'virt_disk_size': virt_size,
	# 'backing_file': backing_file,
	# 'disk_size': dk_size,
	# 'over_committed_disk_size': over_commit_size}
	#
	# img_path格式为/var/lib/nova/instances/vm-uuid/fname
	# from_path格外为/var/lib/nova/instances/vm-uuid_resize/fname
	# tmp_path格式为/var/lib/nova/instances/vm-uuid_resize/fname_rbase

	if info['type'] == 'qcow2' and info['backing_file']:
		tmp_path = from_path + "_rbase"
		# 通过“qemu-img convert”命令将虚拟机的后端镜像和增量镜像合并
		utils.execute('qemu-img', 'convert', '-f', 'qcow2',
						'-O', 'qcow2', from_path, tmp_path)

		if shared_storage:
			# 如果共享storage，此时只要重命名文件
			# 相当于将文件又移到了/var/lib/nova/instances/vm-uuid/fname
			utils.execute('mv', tmp_path, img_path)
		else:
			# 如果是不同主机，那么需要调用如下函数，稍后分析
			libvirt_utils.copy_image(tmp_path, img_path, host=dest,
										on_execute=on_execute,
										on_completion=on_completion)
			utils.execute('rm', '-f', tmp_path)

	# 如果类型是raw或者是没有后端镜像的qcow2，就可以直接转移
	# 如果共享storage，这里的host会是None
	else:
		libvirt_utils.copy_image(from_path, img_path, host=dest,
									on_execute=on_execute,
									on_completion=on_completion)
	\end{lstlisting}

	进一步查看copy\_image函数：
	\begin{lstlisting}
	def copy_image(src, dest, host=None, on_execute=None,
				on_completion=None):
		# 如果共享storage，直接将from_path下的增量文件拷贝到img_path就可以了
		if not host:
			execute('cp', src, dest)
		else:
			dest = "%s:%s" % (host, dest)

			# 通过rsync ssh方式拷贝合并后的镜像到新的host对于instance目录下
			try:
				execute('rsync', '--sparse', '--compress', '--dry-run', src, dest,
						on_execute=on_execute, on_completion=on_completion)
			except processutils.ProcessExecutionError:
				execute('scp', src, dest, on_execute=on_execute,
						on_completion=on_completion)
			else:
				execute('rsync', '--sparse', '--compress', src, dest,
						on_execute=on_execute, on_completion=on_completion)
	\end{lstlisting}

\subsubsection{源主机上冷迁移过程总结}
	根据代码总结源主机上冷迁移步骤：
	\begin{itemize}
		\item[1.] 使用ssh在目的主机上建立虚机的镜像文件的目录。
		\item[2.] 关闭虚拟机。
		\item[3.] 在源宿主机上将虚拟机增量文件所在的目录名加上“\_resize”的后缀。
		\item[4.] 迁移虚拟机的增量文件。这里有多种可能性，详见上述代码的分析。
	\end{itemize}

\clearpage

\subsection{目的主机上的操作}
	LibvirtDriver类中实现finish\_resize()功能的函数是finish\_migration()。\par

	函数代码如下：
	\begin{lstlisting}
	def finish_migration(self, context, migration, instance, disk_info,
                         network_info, image_meta, resize_instance,
                         block_device_info=None, power_on=True):

        # resize disks. only "disk" and "disk.local" are necessary.

		# 调用json.loads()
        disk_info = jsonutils.loads(disk_info)

		# disk_info是一个list，其中存放着一个个字典，格式如下：
		# {'type': disk_type,
		# 'path': path, path的格式为/var/lib/nova/instances/vm-uuid/
		# 'virt_disk_size': virt_size,
		# 'backing_file': backing_file,
		# 'disk_size': dk_size,
		# 'over_committed_disk_size': over_commit_size}
        for info in disk_info:
			# 如果是disk，就返回root分区的大小
			# 如果是disk.local，就返回ephemeral分区的大小
            size = self._disk_size_from_instance(instance, info)

			# 对虚拟机进行扩容
            if resize_instance:
                self._disk_resize(info, size)
			
			# 将磁盘类型转为qcow2
			# 调用命令“qemu-img convert -f raw -O qcow2”
            if info['type'] == 'raw' and CONF.use_cow_images:
                self._disk_raw_to_qcow2(info['path'])

		...

        # 创建image
		# 这个函数在“nova创建虚拟机时对libvirt的调用”一节中有分析
        self._create_image(context, instance,
                           disk_mapping=disk_info['mapping'],
                           network_info=network_info,
                           block_device_info=None, inject_files=False)
		
		# 获得虚拟机xml配置文件
		# 这个函数在“nova创建虚拟机时对libvirt的调用”一节中有分析
        xml = self._get_guest_xml(context, instance, network_info, disk_info,
                                  block_device_info=block_device_info,
                                  write_to_disk=True)
		
		# 创建虚拟机和网络
		# 这个函数在“nova创建虚拟机时对libvirt的调用”一节中有分析
        self._create_domain_and_network(context, xml, instance, network_info,
                                        block_device_info, power_on,
                                        vifs_already_plugged=True)
		
        if power_on:
			# 以下的代码用于检查虚拟机是否运行成功
            timer = loopingcall.FixedIntervalLoopingCall(
                                                    self._wait_for_running,
                                                    instance)
            timer.start(interval=0.5).wait()
	\end{lstlisting}

\subsubsection{对虚拟机进行扩容}
	相关语句与函数如下：
	\begin{lstlisting}
	if resize_instance:
		self._disk_resize(info, size)

	# _disk_resize()函数如下
	def _disk_resize(self, info, size):
        # 函数功能：将一块磁盘扩容为resize大小

		# If we have a non partitioned image that we can extend
        # then ensure we're in 'raw' format so we can extend file system.
        fmt, org = [info['type']] * 2
        pth = info['path']
        if (size and fmt == 'qcow2' and
                disk.can_resize_image(pth, size) and
                disk.is_image_partitionless(pth, use_cow=True)):
			# 调用命令“qemu-img convert -f qcow2 -O raw”
            self._disk_qcow2_to_raw(pth)
            fmt = 'raw'

        if size:
            use_cow = fmt == 'qcow2'
			# 调用命令“qemu-img resize pth size”
			# 如果是raw形式，还会使用resize2fs扩展文件系统
			# 如果是qcow2形式，就挂载设备
            disk.extend(pth, size, use_cow=use_cow)

        if fmt != org:
            # 调用命令“qemu-img convert -f raw -O qcow2”
            self._disk_raw_to_qcow2(pth)
	\end{lstlisting}

\subsubsection{目的主机上冷迁移过程总结}
	根据代码总结目的主机上冷迁移步骤：
	\begin{itemize}
		\item[1.] 首先对disk和disk.local进行扩容。
		\item[2.] 然后创建新的虚拟机，也就是spawn()函数中的那几个步骤。
	\end{itemize}

\clearpage

\section{nova创建快照时对libvirt的调用}
	LibvirtDriver类中创建虚拟机快照的函数是snapshot()。\par

	这个函数主要功能的实现都与libvirt有关，我留取了一些主要的代码，并在之后逐个分析：
	\begin{lstlisting}
	def snapshot(self, context, instance, image_id, update_task_state):

        try:
			# 得到虚拟机的抽象对象virt_dom
            virt_dom = self._lookup_by_name(instance['name'])
        ...

		# 得到虚拟机的磁盘路径
        disk_path = libvirt_utils.find_disk(virt_dom)

		# 得到虚拟机的磁盘类型
        source_format = libvirt_utils.get_disk_type(disk_path)

		# 如果是静态创建快照，将会执行下面这段代码，稍后会在“静态创建快照”一节分析
		if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:
            if state == power_state.RUNNING or state == power_state.PAUSED:
                ...
                virt_dom.managedSave(0)

		# snapshot_backend也将用于静态创建快照，稍后分析
        snapshot_backend = self.image_backend.snapshot(instance,
                disk_path,
                image_type=source_format)

        with utils.tempdir(dir=snapshot_directory) as tmpdir:
            try:
				...
                if live_snapshot:
					# 动态创建快照
                    self._live_snapshot(virt_dom, disk_path, out_path,
                                        image_format)
                else:
					# 静态创建快照
                    snapshot_backend.snapshot_extract(out_path, image_format)
            ...
	\end{lstlisting}

\clearpage

\subsection{获得虚拟机抽象对象}
	函数中的语句如下：
	\begin{lstlisting}
	# instance是Intance类，Instance类定义在nova/objects/instance.py中
	# 返回了virDomain对象
	virt_dom = self._lookup_by_name(instance['name'])
	\end{lstlisting}

	\_lookup\_by\_name()函数如下：
	\begin{lstlisting}
	def _lookup_by_name(self, instance_name):
        try:
			# 这里的_conn就是libvirt API中的virConnect对象
            return self._conn.lookupByName(instance_name)
        ...
	\end{lstlisting}

	lookupByName是libvirt的一个API函数，可以根据域的名字返回virDomain对象。

\subsection{获得虚拟机磁盘路径}
	函数中的语句如下：
	\begin{lstlisting}
	# libvirt_utils在driver.py中有引用：from nova.virt.libvirt import utils as libvirt_utils
	disk_path = libvirt_utils.find_disk(virt_dom)
	\end{lstlisting}

	find\_disk函数如下：
	\begin{lstlisting}
	def find_disk(virt_dom):
		# 在这里，我们只关心下面这条语句
		# virt_dom是libvirt的virDomain对象
		xml_desc = virt_dom.XMLDesc(0)
		...
	\end{lstlisting}

	这里的XMLDesc()是virDomain类的一个成员函数，用于提供域的XML配置文件。
	也就是说，获得虚拟机磁盘路径的核心函数是virDomain.XMLDesc()。\par

	虽然我这里省略了find\_disk()函数接下来的代码，但是大家应该也能知道，
	接下来就是解析这个xml文件，得到域的磁盘路径。

\subsection{获得虚拟机磁盘类型}
	函数中的语句如下：
	\begin{lstlisting}
	# libvirt_utils在driver.py中有引用：from nova.virt.libvirt import utils as libvirt_utils
	# 返回了虚拟机磁盘的类型
	source_format = libvirt_utils.get_disk_type(disk_path)
	\end{lstlisting}

	get\_disk\_type()函数如下：
	\begin{lstlisting}
	def get_disk_type(path):
    ...
	# 这个函数用于得到磁盘的类型
	# qemu_img_info()返回了是QemuImgInfo类
	# QemuImgInfo类定义于nova/openstack/common/imageutils.py中
	# QemuImgInfo.file_format存放着磁盘类型的信息
    return images.qemu_img_info(path).file_format
	\end{lstlisting}

	继续追踪qemu\_img\_info()函数：
	\begin{lstlisting}
	def qemu_img_info(path):
    ...
	# 这条语句相当于执行命令行：qemu-img info disk_path，返回镜像文件的信息
	# utils是nova/utils.py文件
    out, err = utils.execute('env', 'LC_ALL=C', 'LANG=C',
                             'qemu-img', 'info', path)
    ...
	# 返回QemuImgInfo类，这个类定义于nova/openstack/common/imageutils.py中
    return imageutils.QemuImgInfo(out)
	\end{lstlisting}

	所以说，openstack获得虚拟机磁盘信息，最终是调用了“qemu-img info <filename>”这条命令。

\subsection{静态创建快照}
	可以从snapshot()函数知道静态创建快照的相关语句如下：
	\begin{lstlisting}
	...
	if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:
            if state == power_state.RUNNING or state == power_state.PAUSED:
                ...
				# 
                virt_dom.managedSave(0)
	# 获得与静态创建快照有关的数据结构
	snapshot_backend = self.image_backend.snapshot(instance,
                disk_path,
                image_type=source_format)
	...
	with utils.tempdir(dir=snapshot_directory) as tmpdir:
            try:
				...
                else:
					# 静态创建快照
                    snapshot_backend.snapshot_extract(out_path, image_format)
	\end{lstlisting}

\clearpage

	我们逐句分析这三句注释了的代码：
	\begin{itemize}
		\item[1.] 第一句注释代码：
		\begin{lstlisting}
	# virt_dom是libvirt的virDomain对象
	# virDomain.managedSave()函数用于将虚拟机的域挂起，然后将它的内存信息保存到虚拟机镜像的一个文件中
	virt_dom.managedSave(0)
		\end{lstlisting}

		其实第一步已经完成了对虚拟机创建快照，只是现在这个快照保存在镜像文件中，还需要将它提取出来。

		\item[2.] 第二句注释代码：
		\begin{lstlisting}
	# image_backend是nova/libvirt/imagebackend.py文件中定义的Backend类
	# snapshot()函数根据image_type返回相应的类
	snapshot_backend = self.image_backend.snapshot(instance,
                disk_path,
                image_type=source_format)
		\end{lstlisting}

		进一步看snapshot()函数：
		\begin{lstlisting}
	def snapshot(self, instance, disk_path, image_type=None):
		# self.backend()根据image_type返回相应的类
		# 具体细节在此不详述，有兴趣的可以看Backend类
        backend = self.backend(image_type)
        return backend(instance=instance, path=disk_path)
		\end{lstlisting}

		\item[3.] 在分析第三句注释代码前，我先说一些准备信息。\par
		我分析代码的时候，使用的磁盘类型是qcow2类型，所以现在snapshot\_backend是Qcow2类。
		而且现在我们已经通过managedSave()函数将它的快照保存到虚拟机镜像的一个文件中。
		所以使用snapshot\_extract()函数就很好理解了，就是提取快照文件：
		\begin{lstlisting}
	snapshot_backend.snapshot_extract(out_path, image_format)

	# snapshot_extract()函数如下
class Qcow2(Image):
	...
	def snapshot_extract(self, target, out_format):
        libvirt_utils.extract_snapshot(self.path, 'qcow2',
                                       target,
                                       out_format)
		\end{lstlisting}

\clearpage

		代码到了这一步，已经是即将完成快照的提取。
		进一步看extract\_snapshot()函数：
		\begin{lstlisting}
	def extract_snapshot(disk_path, source_fmt, out_path, dest_fmt):
		# 函数相当于执行了“qemu-img convert -f source_fmt -O dest_fmt disk_path out_path”
		# qemu-img convert就是用来提取快照的命令
		qemu_img_cmd = ('qemu-img', 'convert', '-f', source_fmt, '-O', dest_fmt)
		...
		qemu_img_cmd += (disk_path, out_path)
		execute(*qemu_img_cmd)
		\end{lstlisting}
	\end{itemize}

	总结一下，openstack静态创建快照步骤如下：
	\begin{itemize}
		\item[1.] 调用virDomain.managedSave()创建快照。
		\item[2.] 用“qemu-img convert”命令提取快照。
	\end{itemize}

\subsection{动态创建快照}
	snapshot()函数中动态创建快照的相关语句如下：
	\begin{lstlisting}
	...
	with utils.tempdir(dir=snapshot_directory) as tmpdir:
            try:
				...
                if live_snapshot:
					# 动态创建快照
                    self._live_snapshot(virt_dom, disk_path, out_path,
                                        image_format)
				...
	\end{lstlisting}

	进一步看\_live\_snapshot()函数：
	\begin{lstlisting}
	def _live_snapshot(self, domain, disk_path, out_path, image_format):
		# domain是虚拟机的virDomain对象

		# 传入VIR_DOMAIN_XML_INACTIVE和VIR_DOMAIN_XML_SECURE参数
		# 获得domain的xml配置文件
		# 这个xml用于之后的undefine()和define()函数
        xml = domain.XMLDesc(
            libvirt.VIR_DOMAIN_XML_INACTIVE |
            libvirt.VIR_DOMAIN_XML_SECURE)

        try:
			# 调用virDomain.blockJobAbort()停止活动块操作
            domain.blockJobAbort(disk_path, 0)
        ...
		# 获得虚拟机backing_file的路径
        src_back_path = libvirt_utils.get_disk_backing_file(disk_path,
                                                            basename=False)
        disk_delta = out_path + '.delta'
		# 这个函数位于nova/virt/libvirt/utils.py中
		# 函数中调用“qemu-img create -f qcow2 -o src_disk_size,src_back_path src_back_path”创建镜像文件
        libvirt_utils.create_cow_image(src_back_path, disk_delta,
                                       src_disk_size)

        try:
			# 因为virDomain.blockRebase()不能对persistent的domain操作
			# 所以调用virDomain.undefine()将domain变为transient
            if domain.isPersistent():
                domain.undefine()

            # 将虚拟机镜像文件的内容拷贝到disk_delta中的镜像文件中
            domain.blockRebase(disk_path, disk_delta, 0,
                               libvirt.VIR_DOMAIN_BLOCK_REBASE_COPY |
                               libvirt.VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT |
                               libvirt.VIR_DOMAIN_BLOCK_REBASE_SHALLOW)

            ...

			# 调用virDomain.blockJobAbort()终止数据拷贝
            domain.blockJobAbort(disk_path, 0)
            ...
        finally:
			# 将domain从transient变为persistent
            self._conn.defineXML(xml)

        # 这个函数调用“qemu-img convert”命令将disk_delta中的文件变为一个qcow2文件
        libvirt_utils.extract_snapshot(disk_delta, 'qcow2',
                                       out_path, image_format)
	\end{lstlisting}

	总结一下，openstack动态创建快照步骤如下：
	\begin{itemize}
		\item[1.] 使用“qemu-img create”命令创建用于备份的镜像。
		\item[2.] 调用virDomain.blockRebase()函数将虚拟机的磁盘内容拷贝到后端镜像中。
		\item[3.] 使用"qemu-img convert"命令将后端镜像转换为一个qcow2文件。
	\end{itemize}

\clearpage

\section{openstack中对libvirt调用的框架}

\clearpage

\section{查看libvirt的python API}

	可以通过python的help()函数来查看virConnect类：
	\begin{itemize}
		\item[1.] 首先进入python的help界面：
		\sizedfic{0.6}{1.png}

		\item[2.] 查看libvirt的帮助文档：
		\sizedfic{0.6}{2.png}

		\item[3.] 通过“virConnect”找到对virConnect各个函数的介绍：
		\sizedfic{0.6}{3.png}

	\end{itemize}

	% 进一步看\_connect()函数：
	% \begin{lstlisting}
	% @staticmethod
    % def _connect(uri, read_only):
	% 	...
	% 	# 下面这个函数使用Evenlet机制会创建一个线程
    %     return tpool.proxy_call(
    %         (libvirt.virDomain, libvirt.virConnect),
    %         libvirt.openAuth, uri, auth, flags)
	% \end{lstlisting}

\end{document}