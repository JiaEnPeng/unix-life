% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=1.5cm,right=1.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{etoolbox}%
\makeatletter
\patchcmd{\ttlh@hang}{\parindent\z@}{\parindent\z@\leavevmode}{}{}%
\patchcmd{\ttlh@hang}{\noindent}{}{}{}%
\makeatother

\usepackage{hyperref}
\usepackage{longtable}
\usepackage{empheq}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
%\titleformat*{\section}{\LARGE}
%\renewcommand\refname{参考文献}
%\titleformat{\chapter}{\centering\bfseries\huge}{}{0.7em}{}{}
\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{ \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXINGKA.TTF}
%\setCJKfamilyfont{cjkhwxk}{华文行楷}
%\setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
%\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
%\newfontfamily\wryh{Microsoft YaHei}
%\newfontfamily\hwzs{华文中宋}
%\newfontfamily\hwst{华文宋体}
%\newfontfamily\hwfs{华文仿宋}
%\newfontfamily\jljt{方正静蕾简体}
%\newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=python,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

%\newfontfamily{\consolas}{Consolas}
%\newfontfamily{\monaco}{Monaco}
%\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
%\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
%\setmainfont{Times New Roman}
%\setCJKmainfont{STZHONGS.TTF}
%\setmonofont{Consolas}
% \newfontfamily{\consolas}{YaHeiConsolas.ttf}
\newfontfamily{\monaco}{MONACO.TTF}
\setCJKmainfont{STZHONGS.TTF}
%\setmainfont{MONACO.TTF}
%\setsansfont{MONACO.TTF}

\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

\newcommand{\tablestart}{
	\interval
	\begin{longtable}{p{2cm}p{10cm}}
	\hline}
\newcommand{\tableend}{
	\hline
	\end{longtable}
	\interval}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{snapshot优化方案 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}

\begin{document}

\tableofcontents

\clearpage

\section{snapshot的流程}
\subsection{数据结构}

\subsubsection{bdms}
    \begin{lstlisting}
    # nova/objects/block_device.py BlockDeviceMappingList
    \end{lstlisting}

\subsubsection{Image}
    \begin{lstlisting}
    # glance.db.sqlalchemy.models.Image
    \end{lstlisting}

\clearpage

\subsection{快照入口函数}
    \begin{lstlisting}
    # nova/api/openstack/compute/servers.py Controller._action_create_image()
    def _action_create_image(self, req, id, body):
        # id是instance id
        context = req.environ['nova.context']
        # body == {u'createImage': {u'name': u'snap1', u'metadata': {}}}
        entity = body.get("createImage", {})

        image_name = entity.get("name")

        ...

        props = {}
        metadata = entity.get('metadata', {})
        
        try:
            props.update(metadata)
        ...
        # 根据context和req得到Instance类
        instance = self._get_server(context, req, id)

        bdms = objects.BlockDeviceMappingList.get_by_instance_uuid(
                    context, instance.uuid)

        try:
            # 判断root分区是否是volume
            if self.compute_api.is_volume_backed_instance(context, instance,
                                                          bdms):
                img = instance['image_ref']
                if not img:
                    properties = bdms.root_metadata(
                            context, self.compute_api.image_api,
                            self.compute_api.volume_api)
                    image_meta = {'properties': properties}
                else:
                    image_meta = self.compute_api.image_api.get(context, img)
                
                # Snapshot the given volume-backed instance
                image = self.compute_api.snapshot_volume_backed(
                                                       context,
                                                       instance,
                                                       image_meta,
                                                       image_name,
                                                       extra_properties=props)
            else:
                # 做快照的正常流程
                image = self.compute_api.snapshot(context,
                                                  instance,
                                                  image_name,
                                                  extra_properties=props)
        ...

        # 以下代码的功能：build location of newly-created image entity
        image_id = str(image['id'])
        url_prefix = self._view_builder._update_glance_link_prefix(
                req.application_url)
        image_ref = os.path.join(url_prefix,
                                 context.project_id,
                                 'images',
                                 image_id)

        resp = webob.Response(status_int=202)
        resp.headers['Location'] = image_ref
        return resp
    \end{lstlisting}

\subsection{使用RPC与nova-compute服务通信}

    \begin{lstlisting}
    # nova/compute/api.py API.snapshot()
    def snapshot(self, context, instance, name, extra_properties=None):
        # instance: nova.db.sqlalchemy.models.Instance
        # name: name of the snapshot
        # extra_properties: dict of extra image properties to include
        #                   when creating the image.
        # returns: A dict containing image metadata

        # 函数功能：Create new image entry in the image service.  
        #          This new image will be reserved for the compute 
        #          manager to upload a snapshot or backup.
        image_meta = self._create_image(context, instance, name,
                                        'snapshot',
                                        extra_properties=extra_properties)

        # 更改instance的task_state
        instance.task_state = task_states.IMAGE_SNAPSHOT_PENDING
        # 调用Instance.save()方法更改数据库
        instance.save(expected_task_state=[None])

        self.compute_rpcapi.snapshot_instance(context, instance,
                                              image_meta['id'])

        return image_meta
    \end{lstlisting}

    \begin{lstlisting}
    # nova/compute/rpcapi.py ComputeAPI.snapshot_instance()
    def snapshot_instance(self, ctxt, instance, image_id):
        # server: the destination host for a message.
        # server == instance['host']
        cctxt = self.client.prepare(server=_compute_host(None, instance),
                version=version)
        cctxt.cast(ctxt, 'snapshot_instance',
                   instance=instance,
                   image_id=image_id)
    \end{lstlisting}

\subsection{nova-compute中的快照动作}
    \begin{lstlisting}
    # nova/compute/manager.py ComputeManager.snapshot_instance()
    def snapshot_instance(self, context, image_id, instance):
        # context: security context
        # instance: a nova.objects.instance.Instance object
        # image_id: glance.db.sqlalchemy.models.Image.Id
        try:
            # 修改instance的task_state
            instance.task_state = task_states.IMAGE_SNAPSHOT
            # 调用Instance.save()方法更改数据库
            instance.save(
                        expected_task_state=task_states.IMAGE_SNAPSHOT_PENDING)
        ...

        self._snapshot_instance(context, image_id, instance,
                                task_states.IMAGE_SNAPSHOT)
    \end{lstlisting}

    \begin{lstlisting}
    # nova/compute/manager.py ComputeManager._snapshot_instance()
    def _snapshot_instance(self, context, image_id, instance,
                           expected_task_state):
        # self.driver.get_info(instance)["state"]
        current_power_state = self._get_power_state(context, instance)
        try:
            # 修改instance的power_state
            instance.power_state = current_power_state
            instance.save()

            if instance.power_state != power_state.RUNNING:
                state = instance.power_state
                running = power_state.RUNNING

            def update_task_state(task_state,
                                  expected_state=expected_task_state):
                instance.task_state = task_state
                instance.save(expected_task_state=expected_state)

            # 调用LibvirtDriver.snapshot()函数实现快照功能
            self.driver.snapshot(context, instance, image_id,
                                 update_task_state)
            
            # 记录instance状态
            instance.task_state = None
            instance.save(expected_task_state=task_states.IMAGE_UPLOADING)
        ...
    \end{lstlisting}

\subsection{实现快照功能的核心函数}

    \begin{lstlisting}
    def snapshot(self, context, instance, image_id, update_task_state):
        try:
            # 调用virConnect.lookupByName()返回virDomain对象
            virt_dom = self._lookup_by_name(instance['name'])
        ...

        base_image_ref = instance['image_ref']

        # 得到instance的image的相关数据
        base = compute_utils.get_image_metadata(
            context, self._image_api, base_image_ref, instance)
        
        # Retrieves the information record for a single disk image by image_id
        snapshot = self._image_api.get(context, image_id)

        # 通过virtDomain.XMLDesc(0)得到xml配置文件，从而得到instance的磁盘路径
        disk_path = libvirt_utils.find_disk(virt_dom)
        # 使用“qemu-img info disk_path”获得磁盘信息
        source_format = libvirt_utils.get_disk_type(disk_path)

        image_format = CONF.libvirt.snapshot_image_format or source_format

        # NOTE(bfilippov): save lvm and rbd as raw
        if image_format == 'lvm' or image_format == 'rbd':
            image_format = 'raw'
        
        # metadata = {'is_public': False,
        #             'status': 'active',
        #             'name': snp_name,
        #             'properties': {
        #                            'kernel_id': instance['kernel_id'],
        #                            'image_location': 'snapshot',
        #                            'image_state': 'available',
        #                            'owner_id': instance['project_id'],
        #                            'ramdisk_id': instance['ramdisk_id'],
        #                            }
        #             }
        metadata = self._create_snapshot_metadata(base,
                                                  instance,
                                                  image_format,
                                                  snapshot['name'])
        
        # 获得快照的名称
        snapshot_name = uuid.uuid4().hex

        # LIBVIRT_POWER_STATE = {
        #     VIR_DOMAIN_NOSTATE: power_state.NOSTATE,
        #     VIR_DOMAIN_RUNNING: power_state.RUNNING,
        #     VIR_DOMAIN_BLOCKED: power_state.RUNNING,
        #     VIR_DOMAIN_PAUSED: power_state.PAUSED,
        #     VIR_DOMAIN_SHUTDOWN: power_state.SHUTDOWN,
        #     VIR_DOMAIN_SHUTOFF: power_state.SHUTDOWN,
        #     VIR_DOMAIN_CRASHED: power_state.CRASHED,
        #     VIR_DOMAIN_PMSUSPENDED: power_state.SUSPENDED,
        # }
        # 调用virDomain.info()返回[state, maxMemory, memory, nbVirtCPU, cpuTime]
        state = LIBVIRT_POWER_STATE[virt_dom.info()[0]]

        # 动态快照要求QEMU 1.3 and Libvirt 1.0.0
        # Instances with LVM encrypted ephemeral storage只支持静态快照
        if (self._has_min_version(MIN_LIBVIRT_LIVESNAPSHOT_VERSION,
                                  MIN_QEMU_LIVESNAPSHOT_VERSION,
                                  REQ_HYPERVISOR_LIVESNAPSHOT)
             and source_format not in ('lvm', 'rbd')
             and not CONF.ephemeral_storage_encryption.enabled):
            live_snapshot = True
            try:
                # 终止虚拟机磁盘上的active block job
                virt_dom.blockJobAbort(disk_path, 0)
            ...
        else:
            live_snapshot = False

        if state == power_state.SHUTDOWN:
            live_snapshot = False

        # virDomain.managedSave() does not work for LXC
        # 如果是静态快照，需要执行virDomain.managedSave()函数
        if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:
            if state == power_state.RUNNING or state == power_state.PAUSED:
                # 卸载虚拟机的pci设备
                self._detach_pci_devices(virt_dom,
                    pci_manager.get_instance_pci_devs(instance))
                # 关闭SR-IOV端口
                self._detach_sriov_ports(context, instance, virt_dom)
                # This method will suspend a domain and save its memory contents to a file on disk.
                virt_dom.managedSave(0)
            
        # 返回Qcow2类
        # snapshot_backend是nova.virt.libvirt.imagebackend.Qcow2 object
        snapshot_backend = self.image_backend.snapshot(instance,
                disk_path,
                image_type=source_format)

        ...

        update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD)
        # snapshot_directory == /var/lib/nova/instances/snapshots
        snapshot_directory = CONF.libvirt.snapshots_directory
        # 确保有这个目录存在
        fileutils.ensure_tree(snapshot_directory)
        with utils.tempdir(dir=snapshot_directory) as tmpdir:
            try:
                # 得到快照路径
                out_path = os.path.join(tmpdir, snapshot_name)
                if live_snapshot:
                    os.chmod(tmpdir, 0o701)
                    # 动态快照的步骤如下：
                    # disk_path为/var/lib/nova/instances/vm-uuid/disk
                    # out_path为/var/lib/nova/instances/snapshots/snapshot_name
                    # 首先调用”qemu-img create -f qcow2 -o backing_file=disk_path的backing_file,size=disk_path的virtual_size outpath.delta“创建镜像
                    # 然后调用domain.blockRebase(disk_path, disk_delta, 0,
                    #          libvirt.VIR_DOMAIN_BLOCK_REBASE_COPY |
                    #          libvirt.VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT |
                    #          libvirt.VIR_DOMAIN_BLOCK_REBASE_SHALLOW)函数将disk_path的内容拷贝给outpath.delta
                    # 然后使用”qemu-img convert“命令将out_path.delta拷贝到out_path
                    # 这条命令在拷贝过程中，会先把后端镜像和增量镜像合并，然后在拷贝到另外一个镜像文件中，所以会比较久
                    self._live_snapshot(virt_dom, disk_path, out_path,
                                        image_format)
                else:
                    # 使用”qemu-img convert“命令将虚拟机磁盘拷贝到out_path
                    # 这条命令在拷贝过程中，会先把后端镜像和增量镜像合并，然后在拷贝到另外一个镜像文件中，所以会比较久
                    # 如果不想新建立一个镜像，只是想做个快照，那么这是可以改进的一点
                    snapshot_backend.snapshot_extract(out_path, image_format)
            finally:
                new_dom = None
                # NOTE(dkang): because previous managedSave is not called
                #              for LXC, _create_domain must not be called.
                if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:
                    if state == power_state.RUNNING:
                        # 这种情况new_dom == virt_dom
                        new_dom = self._create_domain(domain=virt_dom)
                    elif state == power_state.PAUSED:
                        # 这种情况new_dom == virt_dom.createWithFlags(libvirt.VIR_DOMAIN_START_PAUSED)
                        new_dom = self._create_domain(domain=virt_dom,
                                launch_flags=libvirt.VIR_DOMAIN_START_PAUSED)
                    if new_dom is not None:
                        # 安装原有的pci设备
                        self._attach_pci_devices(new_dom,
                            pci_manager.get_instance_pci_devs(instance))
                        # 开启SR-IOV端口
                        self._attach_sriov_ports(context, instance, new_dom)

            # Upload that image to the image service
            with libvirt_utils.file_open(out_path) as image_file:
                self._image_api.update(context,
                                       image_id,
                                       metadata,
                                       image_file)
    \end{lstlisting}

\section{snapshot优化方案}

\end{document}