% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=[x86masm]Assembler,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{内核雏形 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{从Loader到内核}
	Loader要做的两项工作为：
	\begin{itemize}
		\item[1.] 加载内核到内存。
		\item[2.] 跳入保护模式。
	\end{itemize}

\subsection{加载内核到内存}
	想要将内核加载到内存需要以下步骤：
	\begin{itemize}
		\item[1.] 寻找内核所在位置。
		\item[2.] 将内核读入内存。
	\end{itemize}

	这两个步骤与加载Loader入内存的步骤类似，具体细节在《加载Loader入内存》的文档中有讲清楚，这里就不再展开。\par

	以下是将内核加载到内存的实现代码：
	\begin{lstlisting}
	org 0100h
	; 堆栈基址
	BaseOfStack equ 0100h
	; 内核被加载到的位置
	BaseOfKernelFile equ 0800h
	OffsetOfKernelFile equ 0h

		jmp LABEL_START
		nop

	; FAT12磁盘的头
	BS_OEMName DB 'ForrestY'

	BPB_BytePerSec DW 512 	; 每扇区字节数
	BPB_SecPerClus DB 1   	; 每簇多少扇区 
	BPB_RsvdSecCnt DW 1		; Boot记录占用多少扇区
	BPB_NumFATs DB 2		; 共有多少个FAT表
	BPB_RootEntCnt DW 224	; 根目录文件数最大值
	BPB_TotSec16 DW 2880	; 逻辑扇区总数
	BPB_Media DB 0xF0		; 媒体描述符
	BPB_FATSz16	DW 9		; 每FAT扇区数
	BPB_SecPerTrk DW 18		; 每磁道扇区数
	BPB_NumHeads DW 2		; 磁头数
	BPB_HiddSec DD 0 		; 隐藏扇区数
	BPB_TotSec32 DD 0		; 如果wTotalSectorCount是0，由这个值记录扇区数

	BS_DrvNum DB 0			; 中断13的驱动器号
	BS_Reserved1 DB 0		; 未使用
	BS_BootSig DB 29h		; 扩展引导标记
	BS_VolID DD 0			; 卷序列号
	BS_VolLab DB 'OrangeS0.02' ; 卷标，必须11字节
	BS_FileSysType DB 'FAT12   ' ; 文件系统类型，必须8字节

	FATSz equ 9
	RootDirSectors equ 14
	SectorNoOfRootDirectory equ 19
	SectorNoOfFAT1 equ 1
	DeltaSectorNo equ 17

	LABEL_START:
		mov ax, cs
		mov ds, ax
		mov es, ax
		mov ss, ax
		mov sp, BaseOfStack

		mov dh, 0
		call DispStr

		mov word [wSectorNo], SectorNoOfRootDirectory
		xor ah, ah
		xor dl, dl
		int 13h

	LABEL_SEARCH_IN_ROOT_DIR_BEGIN:
		cmp word [wRootDirSizeForLoop], 0
		jz LABEL_NO_KERNELBIN
		dec word [wRootDirSizeForLoop]
		mov ax, BaseOfKernelFile
		mov es, ax
		mov bx, OffsetOfKernelFile
		mov ax, [wSectorNo]
		mov cl, 1

		mov si, KernelFileName
		mov di, OffsetOfKernelFile
		cld
		mov dx, 10h

	LABEL_SEARCH_FOR_KERNELBIN:
		cmp dx, 0
		jz LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR
		dec dx
		mov cx, 11

	LABEL_CMP_FILENAME:
		cmp cx, 0
		jz LABEL_FILENAME_FOUND
		dec cx
		lodsb
		cmp al, byte [es:di]
		jz LABEL_GO_ON
		jmp LABEL_DIFFERENT

	LABEL_GO_ON:
		inc di
		jmp LABEL_CMP_FILENAME

	LABEL_DIFFERENT:
		and di, 0FFE0h
		add di, 20h
		mov si, KernelFileName
		jmp LABEL_SEARCH_FOR_KERNELBIN

	LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:
		add word [wSectorNo], 1
		jmp LABEL_SEARCH_IN_ROOT_DIR_BEGIN

	LABEL_NO_KERNELBIN:
		mov dh, 2
		call DispStr

	%ifdef _LOADER_DEBUG_
		mov ax, 4c00h
		int 21h
	%else
		jmp $
	%endif

	LABEL_FILENAME_FOUND:
		mov ax, RootDirSectors
		and di, 0FFF0h

		; 记录kernel.bin的大小
		push eax
		mov eax, [es:di+01Ch]
		mov dword [dwKernelSize], eax
		pop eax

		add di, 01Ah
		mov cs, word [es:di] 			; cs保存着簇号
		push cx
		add cx, ax
		add cx, DeltaSectorNo			; cs保存着Kernel.bin的扇区号
		mov ax, BaseOfKernelFile
		mov es, ax
		mov bx, OffsetOfKernelFile
		mov ax, cx

	LABEL_GOON_LOADING_FILE:
		; 打印“.”
		push ax
		push bx
		mov ah, 0Eh
		mov al, '.'
		mov bl, 0Fh
		int 10h
		pop bx
		pop ax

		mov cl, 1
		call ReadSector
		pop ax
		call GetFATEntry
		cmp ax, 0FFFh
		jz LABEL_FILE_LOADED
		push ax
		mov dx, RootDirSectors
		add ax, dx
		add ax, DeltaSectorNo
		add bx, [BPB_BytePerSec]
		jmp LABEL_GOON_LOADING_FILE

	LABEL_FILE_LOADED:
		call KillMotor
		
		mov dh, 1
		call DispStr

		jmp $

	MessageLength equ 9
	LoadMessage	db "Loading  "
	Message1	db "Ready    "
	Message2	db "No Kernel"

	DispStr:
		mov ax, MessageLength
		mul dh
		add ax, 

	KillMotor:
		push dx
		mov dx, 03F2h
		mov al, 0
		out dx, al
		pop dx
		ret
	\end{lstlisting}

\section{跳入保护模式}
	在将内核加载进入内存之后，我们将跳入保护模式。

\subsection{定义GDT表}

	首先我们将创建GDT表，其中存放三个段描述符，
	分别是0～4GB的可执行段、0～4GB的可读写段和指向显存开始地址的段。\par

	定义代码如下所示：
	\begin{lstlisting}
	%macro Descriptor 3
		dw %2 & 0FFFFh
		dw %1 & 0FFFFh
		db (%1 >> 16) & 0FFh
		dw ((%2 >> 8) & 0F00h) | (%3 & 0F0FFh)
		db (%1 >> 24) & 0FFh
	%endmacro

	LABEL_GDT:	Descriptor 0, 0, 0
	LABEL_DESC_FLAT_C:	Descriptor 0, 0fffffh, DA_CR | DA_32 | DA_LIMIT_4K
	LABEL_DESC_FLAT_RW:	Descriptor 0, 0fffffh, DA_DRW | DA_32 | DA_LIMIT_4K
	LABEL_DESC_VIDEO:	Descriptor 0B8000h, 0ffffh, DA_DRW | DA_DPL3

	GdtLen equ $ - LABEL_GDT
	GdtPtr dw GdtLen - 1
		   dd BaseOfLoaderPhyAddr + LABEL_GDT ; BaseOfLoaderPhyAddr是Loader的实际物理地址，加上LABEL_GDT后，是GDT的实际物理地址

	SelectorFlatC equ LABEL_DESC_FLAT_C - LABEL_GDT
	SelectorFlatRW equ LABEL_DESC_FLAT_RW - LABEL_GDT
	SelectorVideo equ LABEL_DESC_VIDEO - LABEL_GDT + SA_RPL3
	\end{lstlisting}

	需要知道的是，Loader的段基址是BaseOfLoader，所以Loader中标号的物理地址可以用“BaseOfLoader*10h+标号的偏移”算出。

\subsection{进入保护模式}
	进入保护模式的代码如下：
	\begin{lstlisting}
	[SECTION .s32]
	ALIGN 32
	[BITS 32]
	LABEL_PM_START:
		mov ax, SelectorVideo
		mov gs, ax
		mov ah, 0Fh
		mov al, 'P'
		mov (gs:((80*0+39)*2)), ax
		jmp $

	LABEL_FILE_LOADED:
		call KillMotor

		mov dh, 1
		call DispStrRealMode

		lgdt [GdtPtr]

		cli

		in al, 92h
		or al, 00000010b
		out 92h, al

		mov eax, cr0
		or eax, 1
		mov cr0, eax

		jmp dword SelectorFlatC:(BaseOfLoaderPhyAddr+LABEL_PM_START)
	\end{lstlisting}

\subsection{保护模式下的操作}
	在保护模式下，我们可以做如下操作：
	\begin{itemize}
		\item[1.] 初始化各个寄存器的值。
		\item[2.] 获得可使用内存的情况。
		\item[3.] 打开分页机制。
	\end{itemize}

\subsubsection{初始化各个寄存器的值}
	代码如下所示：
	\begin{lstlisting}
	StackSpace: times 1024 db 0
	TopOfStack equ BaseOfLoaderPhyAddr + $

	[SECTION .s32]
	ALIGN 32
	[BITS 32]
	LABEL_PM_START:
		mov ax, SelectorVideo
		mov gs, ax

		mov ax, SelectorFlatRW
		mov ds, ax
		mov cs, ax
		mov es, ax
		mov fs, ax
		mov ss, ax
		mov esp, TopOfStack
	\end{lstlisting}

\subsubsection{获得可使用内存}
	在之前说过，使用BIOS中断“int 15h”可以获得内存信息。
	代码如下所示：
	\begin{lstlisting}
		mov ebx, 0
		mov di, _MemChkBuf
	.MemChkLoop:
		mov eax, 0R820h
		mov eax, 20
		mov edx, 053D4150h
		int 15h
		jc .MemChkFail
		add di, 20
		inc dword [_dwMCRNumber]
		cmp ebx, 0
		jne .MemChkLoop
		jmp .MemChkOk
	.MemChkFail:
		mov dword [_dwMCRNumber], 0
	.MemChkOk:
		jmp $
	\end{lstlisting}

	为了让启动过程更多信息，我们还可以添加打印内存信息的函数，代码如下：
	\begin{lstlisting}
	DispMemInfo:
		push esi
		push edi
		push ecx

		mov esi, MemChkBuf
		mov ecx, [_dwMCRNumber]
	
	.loop:
		mov edx, 5
		mov edi, ARDStruct
	.1:
		push dword [esi]
		call DispInt
		pop eax

		stosd

		add esi, 4
		dec edx
		cmp edx, 0
		jnz .1
		call DispReturn
		cmp dword [dwType], 1
		jne .2
		mov eax, [dwBaseAddrLow]
		add eax, [dwLengthLow]
		cmp eax, [dwMemSize]
		jb .2
		mov [dwMemSize], eax

	.2:
		loop .loop

		call DispReturn
		push szRAMSize
		call DispStr
		add esp, 4

		push dword [dwMemSize]
		call DispInt
		add esp, 4

		pop ecx
		pop edi
		pop esi
		ret

	DispAL:
		push ecx
		push edx
		push edi

		mov edi, [dwDispPos]

		mov ah, 0Fh
		mov dl, al
		shr al, 4
		mov ecx, 2
	.begin:
		and al, 01111b
		cmp al, 9
		ja .1
		add al, '0'
		jmp .2
	.1:
		sub al, 0Ah
		add al, 'A'
	.2:
		mov [gs:edi], ax
		add edi, 2

		mov al, dl
		loop .begin

		mov [dwDispPos], edi

		pop edi
		pop edx
		pop ecx

		ret

	; 使用堆栈传递参数
	DispInt:
		mov eax, [esp + 4]
		shr eax, 24
		call DispAL

		mov eax, [esp + 4]
		shr eax, 16
		call DispAL

		mov eax, [esp + 4]
		shr eax, 8
		call DispAL

		mov eax, [esp + 4]
		call DispAL

		mov ah, 07h
		mov al, 'h'
		push edi
		mov edi, [dwDispPos]
		mov [gs:edi], ax
		add edi, 4
		mov [dwDispPos], edi
		pop edi

		ret

	; 使用堆栈传递参数
	DispStr:
		push ebp
		mov ebp, esp
		push ebx
		push esi
		push edi

		mov esi, [esp + 8]
		mov edi, [dwDispPos]
		mov ah, 0Fh
	.1:
		lodsb
		test al, al
		jz .2
		cmp al, 0Ah
		jnz .3
		push eax
		mov eax, edi
		mov bl, 160
		div bl
		and eax, 0FFh
		inc eax
		mov bl, 160
		mul bl
		mov edi, eax
		pop eax
		jmp .1
	.3:
		mov [gs:edi], ax
		add edi, 2
		jmp .1
	.2:
		mov [dwDispPos], edi

		pop edi
		pop esi
		pop ebx
		pop ebp

		ret

	DispReturn:
		push szReturn
		call DispStr
		add esp, 4

		ret

	LABEL_DATA:
	; 实模式下使用的符号
	_szMemChkTitle: db "BaseAddrL BaseAddrH LengthLow LengthHigh   Type", 0Ah, 0
	_szRAMSize: db "RAM size:", 0
	_szReturn: db 0Ah, 0

	_dwMCRNumber: dd 0
	_dwDispPos: dd (80 * 6 + 0) * 2
	_dwMemSize: dd 0
	_ARDStruct:
		_dwBaseAddrLow: dd 0
		_dwBaseAddrHigh: dd 0
		_dwLengthLow: dd 0
		_dwLengthHigh: dd 0
		_dwType: dd 0
	_MemChkBuf: times 256 db 0

	; 保护模式下使用的符号
	szMemChkTitle equ BaseOfLoaderPhyAddr + _szMemChkTitle
	szRAMSize equ BaseOfLoaderPhyAddr + _szRAMSize
	szReturn equ BaseOfLoaderPhyAddr + _szReturn
	dwDispPos equ BaseOfLoaderPhyAddr + _dwDispPos
	dwMemSize equ BaseOfLoaderPhyAddr + _dwMemSize
	dwMCRNumber equ BaseOfLoaderPhyAddr + _dwMCRNumber
	ARDStruct equ BaseOfLoaderPhyAddr + _ARDStruct
		dwBaseAddrLow equ BaseOfLoaderPhyAddr + _dwBaseAddrLow
		dwBaseAddrHigh equ BaseOfLoaderPhyAddr + _dwBaseAddrHigh
		dwLengthLow equ BaseOfLoaderPhyAddr + _dwLengthLow
		dwLengthHigh equ BaseOfLoaderPhyAddr + _dwLengthHigh
		dwType equ BaseOfLoaderPhyAddr + _dwType
	MemChkBuf equ BaseOfLoaderPhyAddr + _MemChkBuf
	\end{lstlisting}

\subsubsection{打开分页机制}
	启动分页的函数如下所示：
	\begin{lstlisting}
	PageDirBase equ 100000h
	PageTblBase equ 101000h

	SetupPaging:
		xor edx, edx
		mov edx, [dwMemSize]
		mov ebx, 400000h
		div ebx
		mov ecx, eax
		test edx, edx
		jz .no_remainder
		inc ecx
	.no_remainder:
		push ecx

		mov ax, SelectorFlatRW
		mov es, ax
		mov edi, PageDirBase
		xor eax, eax
		mov eax, PageTblBase | PG_P | PG_USU | PG_RWW

	.1:
		stosd
		add eax, 4096
		loop .1

		pop eax
		mov ebx, 1024
		mul ebx
		mov ecx, eax
		mov edi, PageTblBase
		xor eax, eax
		mov eax, PG_P | PG_USU | PG_RWW
	.2:
		stosd
		add eax, 4096
		loop .2

		mov eax, PageDirBase
		mov cr3, eax
		mov eax, cr0
		or eax, 80000000h
		mov cr0, eax
		jmp short .3
	.3:
		nop

		ret
	\end{lstlisting}

\subsection{重新放置内核}
	我们将根据ELF文件信息将内核转移到正确的位置，也就是根据ELF文件中的Program header，根据其信息进行内存复制。
	
\subsubsection{内存复制函数}
	代码如下所示：
	\begin{lstlisting}
	; 使用堆栈进行参数的传递
	MemCpy:
		push ebp
		mov ebp, esp

		push esi
		push edi
		push ecx

		mov edi, [ebp + 8]
		mov esi, [ebp + 12]
		mov ecx, [ebp + 16]
	.1:
		cmp ecx, 0
		jz .2

		mov al, [ds:esi]
		inc esi

		mov byte [es:edi], al
		inc edi

		dec ecx
		jmp .1
	.2:
		mov eax, [ebp + 8]

		pop ecx
		pop edi
		pop esi
		mov esp, ebp
		pop ebp

		ret
	\end{lstlisting}

\subsubsection{转移内核}
	转移内核的函数如下：
	\begin{lstlisting}
	InitKernel:
		xor esi, esi
		mov cx, word [BaseOfKernelFilePhyAddr + 2Ch]
		movzx ecx, cx
		mov esi, [BaseOfKernelFilePhyAddr + 1Ch]
		add esi, BaseOfKernelFilePhyAddr
	.Begin:
		mov eax, [esi + 0]
		cmp eax, 0
		jz .NoAction
		push dword [esi + 010h]
		mov eax, [esi + 04h]
		add eax, BaseOfKernelFilePhyAddr
		push eax
		push dword [esi + 08h]
		call MemCpy
		add esp, 12
	.NoAction:
		add esi, 020h
		dec ecx
		jnz .Begin

		ret
	\end{lstlisting}

\section{扩充内核}
\subsection{切换堆栈和GDT}
\subsection{使用makefile}

\end{document}
