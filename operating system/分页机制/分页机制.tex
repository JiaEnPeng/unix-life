% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=[x86masm]Assembler,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{分页机制 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{分页机制}
	分页机制的理论已经在第二次报告中提到了，这里就直接写代码实现吧。
\subsection{分页机制的实现}
\subsubsection{启动分页机制}
	代码中使用两极页表机制，第一级为页目录，大小为4KB，有1024个表项，每个表项对应一个第二级页表。
	第二级页表也有1024个表项，每个表项对应一个物理页。
	首先我会先初始化页目录，然后初始化每一个页表。之后，将页目录基址存放cr3中。然后将cr0的PG位置一，表示开启分页机制。
	我在第一次报告中提到过cr0和cr3，以下是它们的结构图。
	\fic{4.png}
	\fic{5.png}

	在代码中添加SetupPaging函数，用于启动分页机制。代码如下：
	\begin{lstlisting}
	; 页目录为4KB
	PageDirBase equ 200000h
	; 页表开始地址
	PageTblBase equ 201000h
	; ...
	; 在GDT表中添加页目录和页表的描述符
	[SECTION .gdt]
	LABEL_DESC_PAGE_DIR: Descriptor PageDirBase, 4095, DA_DRW
	LABEL_DESC_PAGE_TBL: Descriptor PageTblBase, 1023, DA_DRW | DA_LIMIT_4K
	; ...
	SelectorPageDir equ LABEL_DESC_PAGE_DIR - LABEL_GDT
	SelectorPageTbl equ LABEL_DESC_PAGE_TBL - LABEL_GDT
	; ...
	; 在32位代码段中添加SetupPaging函数，用于启动分页机制
	[SECTION .s32]
	[BITS 32]
	LABEL_SEG_CODE32:
		call SetupPaging
	SetupPaging:
		mov ax, SelectorPageDir
		mov es, ax
		mov ecx, 1024
		xor edi, edi
		xor eax, eax
		mov eax, PageTblBase | PG_P | PG_USU | PG_RWW
	.1:
		; 初始化页目录
		; 将页表的基地址存入页目录中
		; stosd的功能是将eax的内容移入到es所指的地址中
		stosd ; 每次edi会自动加一
		add eax, 4096 ; 一个页表的大小为4KB
		loop .1 ; 当计数寄存器为0时，结束循环

		; 初始化所有页表
		mov ax, SelectorPageTbl
		mov es, ax
		mov ecx, 1024 * 1024
		xor edi, edi
		xor eax, eax
		mov eax, PG_P | PG_USU | PG_RWW
	.2:
		stosd
		add eax, 4096 ; 每个表项指向一个4K的帧
		loop .2
		; 将页目录基地址存入cr3中
		mov eax, PageDirBase
		mov cr3, eax
		; 将cr0的最高位PG标志置一
		mov eax, cr0
		or eax, 80000000h
		mov cr0, eax
		jmp short .3
	.3:
		nop
		ret
	\end{lstlisting}

\subsubsection{利用分页机制节约内存}
	在上一节的代码中，虽然实现了代码，但是也暴露了两个问题：
	\begin{itemize}
		\item 分页机制确实是实现了，但是它没有带来实质性的好处。
		\item 页表占用的内存太大了。
	\end{itemize}

	在代码实现中，我用了4MB的空间用于存放页表，这些页表可以映射4GB的内存空间。
	假设现在的内存空间只有16MB大小，那么页表数根本不需要那么多，只需要4个就够了。
	所以，操作系统有必要知道内存的容量，从而进行内存管理。\par

	可以通过执行指令int 15h，来获得机器内存空间的大小。首先介绍一下int 15h指令。
	15h是中断向量号，进行软中断后，系统会根据eax寄存器的值执行相应的系统调用。
	下面相应的功能表，来源来自维基百科。
	\sizedfic{1}{6.png}
	
	该中断处理函数需要五个输入参数，如下：
	\begin{itemize}
		\item eax。根据上述的功能表可知，当eax = 0E820h时，中断函数将返回机器内存大小。
		\item ebx。ebx放置着"continuation value"，用于寻找下一个地址范围描述符结构ARDS。首次调用int 15h时，将ebx置为0。
		\item es:di。这个指向一个地址范围描述符结构ARDS。
		\item ecx。用于表示ARDS的大小，以字节为单位。
		\item edx。签名‘SMAP’，需要将edx设为0534D4150h，BIOS使用该签名对调用者将要请求的系统映像信息进行校验。
	\end{itemize}

	函数也有五个输出值，如下：
	\begin{itemize}
		\item CF。CF=0，表示没有发生错误。
		\item eax。存放着签名'SMAP'，0534D4150h。
		\item es:di。和输入值相同，指向一个地址范围描述符结构ARDS。
		\item ecx。BIOS会对ARDS进行信息填写，ecx中存放一个数值，这个数值代表了BIOS填写了ARDS多少字节。
		\item ebx。ebx放置着下一个地址描述符所需要的后续值。如果ebx的值为0，代表着当前的ARDS是最后一个地址范围描述符。
	\end{itemize}

	下图是地址范围描述符ARDS的数据结构：
	\fic{7.png}

	其中，Type的取值有三种情况：
	\begin{itemize}
		\item 1，表示这个内存段是一段可以被OS使用的RAM。
		\item 2，表示这个地址段正在被使用或者被系统保留，所以一定不可以被OS使用。
		\item 其他数，表示这个内存段被保留，留作以后使用，不可以被OS使用。
	\end{itemize}

	只能在实模式下使用int 15h，所以在16位代码段中添加相应地代码。将得到的内存空间信息写入缓冲区\_MemChkBuf中。下面是实现代码：
	\begin{lstlisting}
	_MemChkBuf: times 256 db 0
	_dwMCRNumber: dd 0
	; ...
	[SECTION .s16]
	[BITS 16]
		mov ebx, 0 ; 将ebx的值置为一
		mov di, _MemChkBuf ; 将内存信息写入缓冲区
	.loop:
		mov eax, 0E820h
		mov ecx, 20 ; 写入缓冲区的字节数
		mov edx, 0534D4150h
		int 15h
		jc LABEL_MEM_CHK_FAIL ; 检查CF标志
		add di, 20 ; 指向下一个内存信息写入地址
		inc dword [_dwMCRNumber]
		cmp ebx, 0 ; 检查是否为最后一个地址范围描述符
		jne .loop
		jmp LABEL_MEM_CHK_OK
	\end{lstlisting}

	现在内存信息都保存在缓冲区\_MemChkBuf中，需要有相应的代码计算其中的内存大小。
	为了实现这一功能，我定义了一个数据段。并且在32位代码中添加了CalMemSize函数用于计算内存大小。
	下面是实现代码：
	\begin{lstlisting}
	; 定义数据段
	[SECTION .data1]
	ALIGN 32
	[BITS 32]
	LABEL_DATA:
	_szRAMSize db "RAM size:", 0
	_dwMCRNumber: dd 0
	_dwMemSize: dd 0
	; 定义一个ARDS数据结构，大小为20字节
	_ARDSStruct:
		_dwBaseAddrLow: dd 0
		_dwBaseAddrHigh: dd 0
		_dwLengthLow: dd 0
		_dwLengthHigh: dd 0
		_dwType: dd 0
		
	szRAMSize equ _szRAMSize - $$
	dwMemSize equ _dwMemSize - $$
	dwMCRNumber equ _dwMCRNumber - $$
	ARDSStruct equ _ARDSStruct - $$
		dwBaseAddrLow equ _dwBaseAddrLow - $$
		dwBaseAddrHigh equ _dwBaseAddrHigh - $$
		dwLengthLow equ _dwLengthLow - $$
		dwLengthHigh equ _dwBaseAddrHigh - $$
		dwType equ _dwType - $$
	
	; 在32位代码中添加CalMemSize函数
	[SECTION .s32]
	[BITS 32]
	DispMemSize:
		mov ax, SelectorData
		mov ds, ax
		mov es, ax
		mov esi, MemChkBuf
		; mov [ds:dwMCRNumber] to ecx
		mov ecx, [dwMCRNumber]
	.loop:

		; 开始一个循环，将缓冲区中20字节读入ARDS结构中
		mov edx, 5
		; 将es:edi指向_ARDSStruct
		mov edi, ARDSStruct
	.1:
		mov eax, esi
		; 将eax移入[es:edi]，并将edi加4
		stosd
		add esi, 4
		dec edx
		cmp edx, 0
		jnz .1

		cmp dword [dwType], 1 ; 查看内存段的类型
		jne .2 ; 如果内存段可用，则跳转到.2
		mov eax, [dwBaseAddrLow]
		add eax, [dwLengthLow]
		cmp eax, [dwMemSize]
		jb .2
		; mov eax to [es:dwMemSize]
		mov [dwMemSize], eax
	.2:
		loop .loop
	\end{lstlisting}

	这里就能得到内存大小了，存储在dwMemSize中。随后根据内存大小计算应该初始化多少页目录项和页表项。
	下面是实现的代码：
	\begin{lstlisting}
	SetupPaging:
		xor edx, edx
		; eax存放着内存空间总大小
		mov eax, [dwMemSize]
		; ebx存放着一个页表对应的大小
		mov ebx, 40000h
		; div指令，eax除以ebx，商存储在eax中，余数存储在edx中
		div ebx
		; ecx中存放着商
		mov ecx, eax
		; 检查余数是否为0
		test edx, edx
		jz .no_remainder
		; 如果余数不为零，需要初始化的页表数加一
		inc ecx
	.no_remainder:
		push ecx
		; 虽然根据ecx中值的大小初始化页目录和页表
	\end{lstlisting}

\subsection{感受分页机制}
	由于分页机制的存在，程序使用的都是线性地址空间，而不再是物理地址。
	这样操作系统就为应用程序提供了一个不依赖于物理内存的平台，应用程序也不必关心实际上有多少物理内存，也不必关心正在使用的是哪一段内存，
	甚至不必关心某一个地址是在物理内存里面还是在硬盘中。\par
	首先说一下我想实现的功能。我定义了两个函数ProcPagingDemo和LinearAddrDemo，ProPagingDemo函数实现了向LinearAddrDemo这个线性地址的转移。
	一开始，我让LinearAddrDemo映射到物理地址空间中的ProcFoo处。虽然我切换页目录表和页表，让LinearAddrDemo映射到ProcBar这个物理地址上。\par
	程序一开始的时候，分页机制是默认物理地址等于线性地址的。这样我让LinearAddrDemo和ProcFoo的值相等，这样调用LinearAddrDemo时，就相当于调用ProcFoo处的代码。
	虽然分页机制将LinearAddrDemo映射到ProcBar，这样调用LinearAddrDemo时，就相当于调用ProcBar处的代码。\par
	\begin{lstlisting}
	LinearAddrDemo equ 00401000h
	ProcFoo equ 00401000h
	ProcBar equ 00501000h
	ProcPagingDemo equ 00301000h
	\end{lstlisting}

	为了将代码放置在ProcFoo和ProcBar这两个地方，还需要写两个函数，在程序运行时将这两个函数的执行代码复制过去。所以需要写一个复制函数MemCpy。
	实现代码如下：
	\begin{lstlisting}
	; void* MemCpy(void* es:pDest, void* ds:pSrc, int iSize);
	MemCpy:
		push ebp
		mov ebp, esp

		push esi
		push edi
		push ecx

		mov edi, [ebp + 8] ; pDest
		mov esi, [ebp + 12] ; pSrc
		mov ecx, [ebp + 16] ; iSize
	.1:
		cmp ecx, 0
		jz .2

		mov al, [ds:esi]
		inc esi

		mov byte [es:edi], al
		inc edi

		dec ecx
		jmp .1
	.2:
		mov eax, [ebp + 8]

		pop ecx
		pop edi
		pop esi
		mov esp, ebp
		pop ebp

		ret
	\end{lstlisting}

	这个代码是逐字节复制的，比较简单，就不详细说明了。需要注意的是，这个函数假设源数据存放在ds段中，目的地址在es段中，所以在调用这个函数之前，需要给ds和es赋值。
	而且这个函数需要三个参数，根据实现代码，需要将长度、源代码地址和目的地址压入栈中。需要注意的是，因为在调用函数之前压入了3个参数，一个参数的大小是4字节。
	为了在调用函数结束后跳过这三个参数，需要将esp指针的值加12。\par
	下面是相应的初始化代码：
	\begin{lstlisting}
	PagingDemo:
		mov ax, cs
		mov ds, ax
		mov ax, SelectorFlatRW
		mov es, ax

		push LenFoo
		push OffsetFoo
		push ProcFoo
		call MemCpy
		add esp, 12

		push LenBar
		push OffsetBar
		push ProcBar
		call MemCpy
		add esp, 12

		push LenPagingDemoAll
		push OffsetPagingDemoProc
		push ProcPagingDemo
		call MemCpy
		add esp, 12

	PagingDemoProc:
	OffsetPagingDemoProc equ PagingDemoProc - $$
		mov eax, LinearAddrDemo
		call eax
		retf
	LenPagingDemoAll equ $ - PagingDemoProc

	foo:
	OffsetFoo equ foo - $$
		mov ah, 0Ch
		mov al, 'F'
		mov [gs:((80 * 17 + 0) * 2)], ax
		mov al, 'o'
		mov [gs:((80 * 17 + 1) * 2)], ax
		mov [gs:((80 * 17 + 2) * 2)], ax
		ret
	LenFoo equ $ - foo
	
	bar:
	OffsetBar equ bar - $$
		mov ah, 0Ch
		mov al, 'B'
		mov [gs:((80 * 18 + 0) * 2)], ax
		mov al, 'o'
		mov [gs:((80 * 18 + 1) * 2)], ax
		mov [gs:((80 * 18 + 2) * 2)], ax
		ret
	LenBar equ $ - bar
	\end{lstlisting}

	所有初始化工作做好之后，就可以在分页机制下，通过调用ProcPagingDemo从而调用LinearAddrDemo线性地址处的代码。
	注意，LinearAddrDemo的值是00401000h。而分页机制中直接让线性地址等于物理地址。
	所以页表中偏移00401000h的位置指向的就是00401000h，也就是SelectorFlatRW:ProcFoo函数的地址。
	这样相当于调用ProcFoo处的代码。
	调用代码如下：
	\begin{lstlisting}
	; 通过分段机制得到相应的线性地址LinearAddrDemo
	; LinearAddrDemo为00401000h
	; 高10位为0000000001b，这样对应页目录中的第二个页表
	; 中间10位为000000000001b，这样对应页表中的第二个页
	; 一个页的大小是4k，一个页表就能指向4M的地址
	; 第二个页表的第二个页就是4M+4k，所以物理地址是00401000h
	; 所以LinearAddrDemo线性地址对应的代码是ProcFoo
	call SelectorFlatC:ProcPagingDemo
	\end{lstlisting}

	之后变换页表和页目录，让页表中偏移00401000h的位置指向的是00501000h，也就是ProcBar函数的地址。
	下面是切换页目录和页表的实现代码：
	\begin{lstlisting}
	PSwitch:
		mov ax, SelectorFlatRW
		mov es, ax
		mov edi, PageDirBase1
		xor eax, eax
		mov eax, PageTblBase1 | PG_P | PG_USU | PG_RWW
		mov ecx, [PageTableNumber]
	.1:
		stosd
		add eax, 4096
		loop .1

		mov eax, [PageTableNumber]
		mov ebx, 1024
		mul ebx
		mov ecx, ecx
		mov edi, PageTblBase1
		xor eax, eax
		mov eax, PG_P | PG_USU | PG_RWW
	.2:
		stosd
		add eax, 4096
		loop .2

		; 改变了LinearAddrDemo对应的物理地址
		; 处理LinearAddrDemo的高10位，也就是页目录的偏移量
		mov eax, LinearAddrDemo
		shr eax, 22
		mov ebx, 4096
		mul ebx 
		; ecx此时存放着相应页表的偏移字节
		mov ecx, eax

		; 处理LinearAddrDemo的中间10位，也就是页表的偏移量
		mov eax, LinearAddrDemo
		shr eax, 12
		and eax, 03FFh
		mov ebx, 4
		mul ebx ; eax此时存放着页表的偏移字节
		; 加上ecx后，eax此时存放着相应页的偏移字节
		add eax, ecx
		; 加上PageTblBase1，得到LinearAddrDemo所指的项
		add eax, PageTblBase1
		; 将该项的内容改为ProcBar的地址
		mov dword [es:eax], ProcBar | PG_P | PG_USC | PG_RWW

		; 改变cr3的值来切换页目录
		mov eax, PageDirBase1
		mov cr3, eax
		jmp short .3
	.3:
		nop
		ret
	\end{lstlisting}

	改变后，线性地址LinearAddrDemo对应的物理地址是ProcBar。
	再次调用SelectorFlatC:ProcPagingDemo，就会调用ProcBar函数。


\end{document}
