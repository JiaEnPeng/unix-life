第四章 80X86保护模式及其编程

4.0 本章将学习的东西
{
    1.80X86基础知识
    2.保护模式内存管理
    3.各种保护措施
    4.中断和异常处理
    5.任务管理
    6.保护模式编程的初始化
    7.一个简单的多任务内核例子
}

4.1 80X86基础知识
{
    80X86有一个标志寄存器EFLAGS和几个系统寄存器
    
    4.1.1 标志寄存器
    {
        EFLAGS中的系统标志位有TF,IOPL,NT,RF,VM
        TF：一个跟踪标志。当设置该位时，可为调试系统启动单步执行方式，复位时禁止单步执行。如果POPF、POPFD或IRET指令设置了TF标志，那么在之后处理器就会产生一个调试异常。
        IOPL：I/O特权级字段。当前运行程序或任务的CPL必须小于等于这个IOPL才能访问I/O地址空间。只有当CPL为特权级0时，程序才可以使用POPF或IRET指令修改这个字段。
        NT：嵌套任务标志，控制着被中断任务和调用任务之间的链接关系。在使用CALL指令、中断或异常执行任务调用时，处理器会设置该标志。在通过IRET指令从一个任务返回时，处理器会设置该标志。在通过使用IRET指令从一个任务返回时，处理器会检查并修改这个NT标志。
        RF：恢复标志，用于控制处理器对断点指令的响应。当设置时，该标志会临时禁止断点指令产生的调试异常。当该标志复位时，该断点指令将会产生异常。RF的主要功能就是允许在调试异常之后重新执行一条指令。
        VM：虚拟-8086方式，当设置该标志时，就开启虚拟-8086方式，当复位该标志时，则回到保护模式。
    }

    4.1.2 内存管理寄存器
    {
        处理器提供了4个内存管理寄存器：GDTR、LDTR、IDTR和TR，用于指定分段内存管理所使用的系统表的基地址。
        GDTR、IDTR和LDTR用于寻址存放着描述符表的段，TR用于寻址一个特殊的任务状态段TSS，TSS段中包含着当前执行任务的重要信息。
        GDTR
        {
            功能：用于存放全局描述符表GDT的32位线性基地址和16位表长度值。基地址指定GDT表中字节0在线性地址空间中的地址，表长度指明GDT表的字节长度值。
            相关指令：LGDT用于加载GDTR寄存器的内容，SGDT用于保存GDTR寄存器中的内容。
            GDTR复位后，基地址被默认设置为0，而表长度被设置为0xFFFF。
            在保护模式初始化过程中必须给GDTR加载一个新值。
        }
        IDTR
        {
            功能：用于存放中断描述符表IDT的32位线性基地址和16位表长度值。
            相关指令：LIDT用于加载IDTR中的内容，SIDT用于保存IDTR中的内容。
            IDTR复位后，基地址被默认设置为0，而表长度值被设置为0xFFFF。
        }
        LDTR
        {
            功能：用于存放局部描述符表LDT的32位线性基地址、16位段限长和描述符属性值。
            相关指令：LLDT用于加载LDTR中的内容，SLDT用于保存LDTR中的内容。
            LDTR复位后，基地址被默认设置为0，而表长度被设置为0xFFFF。
            包含LDT表的段必须在GDT表中有一个段描述符项。
            当使用LLDT指令把含有LDT表段的选择符加载进LDTR时，LDT段描述符的段基址地址、段限长符以及描述符属性会被加载到LDTR中。
        }
        TR
        {
            功能：用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值。
            相关指令：LTR、STR
            当进行任务切换时，处理器会把新任务TSS的段选择符和段描述符自动地加载进任务寄存器TR中。
        }
    }

    4.1.3 控制寄存器
    {
        控制寄存器CR0、CR1、CR2和CR3。
        CR0
        {
            含有控制处理器操作模式和状态的系统控制标志
            ET：扩展类型标志。标志为1时，表示使用80387协处理器，并使用32位协处理器协议。标志为0表示使用80287协处理器。如果仿真位EM为1，则该位被忽略。
            TS：任务已切换标志。用于推迟保存任务切换时的协处理器内容，直到新任务开始执行协处理器指令。处理器在每次任务切换时都会设置该标志，并且在执行协处理器指令时测试该标志。详细过程：在任务切换时，处理器并没有自动保存协处理器的上下文，而是设置TS标志。这个标志使得处理器在执行新任务指令流的任何时候遇到一条协处理器指令时产生设备不存在异常。于是设备不存在异常的处理程序使用CLTS指令清除TS标志，并且保存协处理器的上下文。
            EM：仿真标志。标志为1时，表示处理器没有内部或外部协处理器，执行协处理器指令时会引起设备不存在异常。标志为0时，表示系统有协处理器。设置这个标志可以迫使所有浮点指令使用软件来模拟。
            MP：监控协处理器标志。用于控制WAIT/FWAIT指令与TS标志的交互作用。如果MP和TS同时为1，那么执行协处理器指令会引起设备不存在异常。
            PE：启用保护标志。当标志为1时，表示保护模式开启。标志为0时，表示实地址模式开启。这个标志仅开启段级保护。
            PG：分页标志。PG和PE同时为1时，表示分页机制开启。标志为0时，则禁止分页机制，此时所有线性地址等同于物理地址。
            WP：写保护标志。标志为1时，处理器禁止超级用户程序向用户级只读页面执行写操作。该标志用于支持进程创建时的写时复制技术。
            NE：协处理器错误标志。标志为1时，X87协处理器内部错误报告机制启动。

            PE和PG位分别用于控制分段和分页机制。如果不在保护模式下，系统无法启动分页机制。
            只有当执行程序有部分代码和数据在线性地址空间和物理地址空间中具有相同地址时，我们才能改变PG位的位置。
            在修改了PE位之后程序必须立刻使用一条跳转指令，以刷新处理器执行管道中已经获取的不同模式下的任何指令。
            系统刚上电时，PE和PG被复位，以允许引导代码在启动分段和分页机制之前能够初始化这些寄存器和数据结构。
        }
        CR1保留不用
        CR2中含有导致页错误的线性地址
        CR3中含有页目录表物理内存基地址，因此也被称为页目录基地址寄存器PDBR
    }
}

4.2 保护模式内存管理
{
    4.2.1 内存寻址
    {
        定义：对存储在内存中的某个指定数据对象的地址进行定位。
        80X86的地址总线宽度为32位，意味着可以寻址4G字节的物理内存。
        内存地址通常从0开始编址。
        80X86使用一种称为段的寻址技术进行内存寻址。
        段寻址技术：把内存空间分成一个或多个段的线性区域。对内存中一个数据对象的寻址就需要使用一个段的起始地址(段地址)和一个段内偏移地址。
        段地址使用16位的段选择符指定，而段内偏移地址部分使用32位的值来指定，因此一个段的最大长度可达4G。
        程序中由16位的段和32位的偏移构成的48位地址成为一个逻辑地址(虚拟地址)。

        80X86为段地址提供了6个存放段选择符的段寄存器：CS、DS、ES、SS、FS和GS。
        CS用于寻址代码段。由CS寻址的段称为当前代码段，此时EIP寄存器中包含了当前代码段内下一条要执行指令的段内偏移地址。因此要执行指令的地址可以表示成CS:EIP。可以使用段间控制转移指令来为CS和EIP赋予新值。
        SS用于寻址堆栈段。由SS寻址的段称为当前堆栈段，栈顶由ESP寄存器内容指定，因此堆栈顶地址为SS:ESP。
        另外4个段寄存器是通用段寄存器。当指令中没有指定所操作数据的段时，那么DS将是默认的数据段寄存器。

        段内偏移地址由基地址、变址和偏移量组成。
    }

    4.2.2 地址变换
    {
        作用：让操作系统在给任务分配内存时具有灵活性。地址变换同时提供了内存保护功能，因为它能让某些物理地址不被任何逻辑地址所映射。

        两种广泛使用的地址变换技术：分段机制和分页机制。

        从逻辑地址到物理地址的变换过程
        {
            逻辑地址：选择符:偏移值
            物理地址：处理器在其地址总线上能够产生的地址范围。

            首先使用分段机制把程序的逻辑地址变换成线性地址空间。
            然后使用分页机制把线性地址转换成物理地址。
            分段变换机制总是使用，而分页机制选用。

            分段机制
            {
                将处理器可寻址的线性地址空间划分为一些较小的称为段的保护地址空间。
                段可以用来存放程序的代码、数据和堆栈，也可以用来存放系统数据结构。

                逻辑地址中的段选择符用于标识段，同时段选择符提供了段描述符表中的段描述符的偏移量。
                每个段都有一个段描述符，段描述符指明了段的大小、访问权限和段的特权级、段类型以及段基址
                描述符中的段基址加上逻辑地址中的偏移量等于线性地址空间中的地址。
            }

            分页机制
            {
                虚拟存储：一种内存管理技术，让编程人员产生内存空间要比计算机中设计物理内存容量大很多的错觉

                当使用分页时，每个段被划分为页面，页面会被存储于物理内存或者硬盘中。操作系统通过维护一个页目录和一些页表来哦留意这些页面。
                段表存储在线性地址空间，而页表存储在物理地址空间中
            }

            保护
            {
                1.任务之间的保护
                {
                    方法：通过把每个任务放置在不同的虚拟地址空间，并给予每个任务不同的逻辑地址到物理地址的变换映射

                    所有任务都具有的虚拟地址空间被称为全局地址空间。所以任务在全局地址空间中对相同虚拟地址的引用将被转换到同一个物理地址处。
                    每个任务唯一的虚拟地址空间被称为局部地址空间。每个任务具有不同的局部地址空间，两个不同任务中对相同虚拟地址处的引用将转换到不同的物理地址处。
                    每个任务都有自己的段表和页表，也就是映射表，用于把逻辑地址映射到物理地址空间。
                    当处理器切换到执行一个新任务时，任务切换的关键部分就是切换到新任务的变换表。
                }

                2.特权级保护
                {
                    特权级用数字0到3表示，0代表最高特权级，而3则是最低特权级。
                    当前特权级CPL确定了哪些段能够被程序访问。
                    每个特权级都有自己的程序段。当程序从一个特权级切换到另一个特权级执行时，堆栈段也随之切换到新级别的堆栈中。
                }
            }
        }
    }
}

4.3 分段机制
{
    多段模型能够利用分段机制提供由硬件增强的代码、数据结构、程序和任务的保护措施。
    访问检查能够用来保护对段界限以外地址的引用，也能用于在某些段中防止执行不允许的操作。

    4.3.1 段的定义
    {
        分段机制就是把虚拟地址空间中的虚拟内存组织称一些长度可变的称为段的内存块单元。
        虚拟地址空间中的虚拟地址由一个段部分和一个偏移部分构成。
        段氏虚拟地址到线性地址转换机制的基础。
        段由三个参数定义：段基地址、段限长和段属性。
        段基址和段限长定义了段所能映射到的线性地址范围或区域。段内0到limit对应线性地址中范围base到base+limit。
        段描述符：一个结构项，里面存储了段基地址、段限长和段的保护属性。
        段描述符表是一个存放段描述符的数组。

        访问线性地址空间的过程：我们拥有一个字节的逻辑地址，使用逻辑地址中的段选择符来获得段描述符表中这个字节相应的段描述符。字节的段描述符指定了字节所在的段。而逻辑地址中的偏移量指定了该字节在段中相对于段基地址的位置。

        为了把逻辑地址转换成一个线性地址，处理器会执行以下操作
        {
            1.使用段选择符中的段索引在GDT或LDT表中定位相应的段描述符。
            2.利用段描述符检验段的访问权限和范围，以确保该段是可访问的并且偏移量位于段界限哪。
            3.把段描述符中取得的段基地址加到偏移量上，最后形成一个线性地址。
        }
    }

    4.3.2 段描述符表
    {
        段描述符表是段描述符的一个数组，该数组长度可变，多长可为8192。
        系统中有两种描述符表：全局描述符表盒局部描述符表。

        描述符表存储在由操作系统维护着的特殊数据结构中，并且由处理器的内存管理硬件来引用。
        这些特殊数据结构应该保存在仅由操作系统软件访问的受保护的内存区域中。
        通过一个描述符表和表中的描述符号，我们就可以获得一个段描述符。

        整个虚拟地址空间共含有2^14个段，一半的段由GDT来映射，而另一半而LDT映射。
        GDT映射的段一般有两种：操作系统的段以及所有任务各自的包含自身LDT的段。
        操作系统的段可以让系统中所有的任务共享。

        每个操作系统必须定义一个GDT，而LDT可以定义多个。
        GDTR寄存器用于存放GDT的基地址和长度。GDT的基地址应该进行内存8字节对齐，而GDT的长度应该设置为8的倍数减一。
        LDTR寄存器用于存放LDT的段选择符、基地址、段限长以及访问权限。

        LDT表存放在LDT类型的系统段中，GDT必须含有LDT的段描述符和段选择符。
    }

    4.3.3 段选择符
    {
        段选择符并不直接指向段，而是指向段描述符表中定义段的段描述符。
        段选择符三个字段内容：请求特权级RPL、表指示标志TI和索引值
        TI为0表示描述符在GDT中，而TI为1表示描述符在LDT中。
        请求特权级RPL提供了段保护信息。

        处理器提供了6个用于存放段选择符的寄存器，也叫做段寄存器。
        每个段寄存器支持特定类型的内存引用。
        有代码段寄存器、数据段寄存器和堆栈段寄存器，以及三个辅助的数据段寄存器，用于让当前程序访问其他几个数据段。
        段寄存器有可见部分和隐藏部分，可见部分是段选择符，而隐藏部分包含了段描述符中的三个数据，也就是段基地址、段限长和段属性信息。
        当一个段选择符被加载到一个段寄存器可见部分中时，处理器同时也把段选择符指向的段描述符中的段地址、段限长以及访问控制信息加载到段寄存器的隐藏部分。
    }

    4.3.4 段描述符
    {
        段描述符存放在段描述符表中，我们可以使用段选择符中的索引值来定位段描述符表中的段描述符。
        段描述符通常由编译器、链接器、加载器或者操作系统来创建。需要注意的是，应用程序不能创建段描述符。

        注意：80X86的栈总是向下扩展的。

        一个段描述符的各字段和标志的含义如下
        {
            段限长字段LIMIT：段限长limit用于指定段的长度。根据颗粒度标志G来指定段限长的实际含义，G为0时，limit从一字节到1MB字节。如果G为1，limit范围从4KB到4GB。
            基地址字段BASE：定义了4GB线性地址空间中一个段字节所处的位置。
            段类型字段TYPE：用于指定段的类型，说明段的访问种类以及段的扩展方向。TYPE字段的编码对代码、数据或系统描述符都不同。
            描述符类型标志S：当S为1时，段描述符是代码或数据段描述符。当S为0时，段描述符是系统段描述符。
            描述符特权级字段DPL：描述符特权级，用于控制对段的访问。
            段存在标志P：当P为0时，标识了段不在内存中。当P为1时，标识了段在内存中。当段不在内存中的时候，如果把段描述符加载到段寄存器就会产生一个段不存在异常。
            D/B标志：根据段描述符的类型，这个标志有不同的功能。当段是可执行代码段时，该标志用于指出代码段中有效地址和操作数的默认长度。当段为栈段时，用于指明堆栈段中的栈指针默认长度。当段为下扩数据段时，用于指明堆栈堆上界限的默认大小。
            颗粒度标志G：当字段用于指明段限长字段limit值的单位。当G为0时，段限长单位为字节，而当G为1时，段限长单位为4KB。
            可用和保留比特位：位21总是设置为0，而位20供系统软件使用。
        }
    }

    4.3.5 代码和数据段描述符
    {
        当描述符类型标志S为1时，该描述符用于代码或数据段。
        段类型字段TYPE为8到11。数据段为0EWA，代码段为1CRA(从高位到低位)。
        
        堆栈段必须是可读/写的数据段。
        已访问比特位A用于指明从上次操作系统复位该位之后一个段是否被访问过。当一个段被加载进段寄存器，A就被置位。
    }

    4.3.6 系统描述符
    {
        有六种系统描述符
        {
            1.局部描述符表描述符
            2.任务状态段描述符
            3.调用门描述符
            4.中断门描述符
            5.陷阱门描述符
            6.任务门描述符

            关于任务状态段描述符河任务门的使用方法将在任务管理中说明
            调用门描述符将在保护一节中说明
            中断和陷阱门将在中断和异常处理一节中说明
        }
    }
}

4.4 分页机制
{
    分页机制在分段机制的基础上完成逻辑地址向物理地址转换的过程
    通过设置CR0的PG位可以开启分页机制。
    如果PG为1，则启动分页操作。如果PG为0，则分段机制产生的线性地址空间将直接被用作物理地址。

    分页机制对固定大小的内存块进行操作。
    分页机制将线性和物理地址空间都划分为各个页面，在两个空间之间提供了任意映射。

    4.4.1 页表结构
    {
        分页转换功能由驻留在内存中的表来描述，这个表称为页表。
        页表存放在物理地址空间中。
        页表相当于一个存放物理地址的数组，线性地址到物理地址的映射相当于在该数组中找到相应的物理地址。
        
        经过分段机制后，我们由逻辑地址得到线性地址，这个线性地址有32位。
        在分页机制中，我们使用线性地址中的高20位来作为页表数组的索引值，从而找到相应物理地址的基地址。而把线性地址的低12位作为在页面中的偏移量，加上页面的基地址最终形成对应的物理地址。

        4.4.1.1 两级页表结构
        {
            第一级表称为页目录表。这个也是一个数组，用于存放二级表。这个数组的大小为2^10,我们使用线性地址的高10位作为一级表的索引值，用于得到二级表。
            第二级表称为页表，是用于存放物理基地址的数组。我们使用线性地址的中间10位作为页表的索引值，用于获取物理基地址，加上页内偏移得到最终的物理地址。

            CR3中存放了页目录表基地址。
            二级表结构允许页表被分散在内存各个页面中，而不需要保存在连续的4MB内存块中。
            第一级表总是必须存在于物理内存中，而第二级表可以在需要时分配。这使得页表结构的大小不必为4MB。

            第二级表分配机制
            {
                页目录表中的每一项都有一个存在属性，用于指明第二级表是否存在。
                当第二级表存在时，则顺利转换为物理地址。
                当第二级表不存在时，处理器产生一个异常来通知操作系统，操作系统根据实际使用的线性地址范围来分配第二级表。

                第二级表还可以存放在磁盘上。
                存放在物理内存的页表被标注为存在，存放在磁盘上的页表被标注不存在。当使用不存在的页表时，处理器产生异常通知操作系统把缺少的页表从磁盘上加载进物理内存。
            }
        }
    }
}

4.5 保护
{
    保护机制：当程序对错误内存空间执行了一次非期望的饮用，保护机制可以阻止这种操作并且报告此类事件。

    操作系统通过设置寄存器CR0的PE标志来开启分段保护机制。
    寄存器CR0的PG标志可以开启分页机制，同时也开启了分页保护机制。

    4.5.1 段级保护
    {
        保护检查有以下几类
        {
            1.段界限检查
            2.段类型检查
            3.特权级检查
            4.可寻址范围限制
            5.过程入口点限制
            6.指令集限制
        }
    }
}