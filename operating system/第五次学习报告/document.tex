% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=[x86masm]Assembler,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{第五次学习报告 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{实现特权级转移}
\subsection{理论知识}
	特权级转移需要借助堆栈切换。当调用门用于把程序控制转移到一个更高级别的非一致性代码段时，处理器会自动切换到目的代码段特权级的堆栈。
	此时处理器会按照以下步骤切换堆栈：
	\begin{itemize}
		\item 当前任务的TSS段存放着特权级0、1和2的堆栈的初始指针值。处理器会将目的代码段的DPL作为新任务的CPL，并从TSS中选择新栈的SS和ESP。
		\item 将SS和ESP寄存器的当前值压入新栈，并将新栈的段选择符和栈指针加载到SS和ESP。
		\item 将调用门描述符中指定的参数从当前栈压入新栈。参数数目由调用门描述符中的PARAM COUNT字段决定。
		\item 将CS和EIP寄存器的当前值压入新栈，并将目的代码段选择符加载到CS，将调用门选择符中的偏移值加载到EIP中。
	\end{itemize}

	调用过程如下图所示：
	\fic{1.png}

	当调用过程结束后，处理器使用RET执行远返回到一个调用过程。此时CPU会执行以下步骤：
	\begin{itemize}
		\item 检查保存的CS寄存器中的RPL字段值，以确定返回时特权级是否需要改变。
		\item 弹出新栈中的CS和EIP值，并且检查代码段描述符的DPL和代码段选择符的RPL。
		\item 如果返回过程会改变特权级，而且此时RET指令包含一个参数个数操作数，那么就需要在弹出CS和EIP之后，将参数个数值加载到ESP寄存器中，用于丢弃新栈中的参数。
		\item 弹出SS和ESP，从而切换回调用者的堆栈。
		\item 检查DS、ES、FS和GS，如果其中的段选择符指向的段描述符的DPL小于新CPL(仅适用于一致代码段)，处理器将用空选择符来加载这个段寄存器。
	\end{itemize}

	综上，使用调用门实现不同特权级之间的调用可以分为两个过程，一个是通过调用门和call指令实现从低特权级转移到高特权级，
	另一个是通过ret指令实现从高特权级到低特权级。

\subsection{代码实现}
\subsubsection{高特权级到低特权级}
	根据上一节可知，处理器通过ret指令实现从高特权级到低特权级。在ret指令执行之前，堆栈中应该已经有了ss、esp、cs和eip。如下图所示：
	\fic{2.png}

	首先添加一个特权级为3的代码段，为了实现代码段转移，我们需要添加一个代码段和相应的堆栈段。
	先是在GDT表中添加该代码段和堆栈段的描述符，然后定义堆栈段ring3和代码段ring3。随后，我们在32位代码段中通过执行retf指令跳转到ring3代码段中。
	\begin{lstlisting}
	; 在GDT中添加相应的代码段和堆栈段
	[SECTION .gdt]
	; ...
	; 特权级为3
	LABEL_DESC_CODE_RING3: Descriptor 0, SegCodeRing3Len-1, DA_C+DA_32+DA_DPL3
	LABEL_DESC_STACK3: Descriptor 0, TopOfStack3, DA_DRWA+DA_32+DA_DPL3
	; ...
	; 请求特权级为3
	SelectorCodeRing3 equ LABEL_DESC_CODE_RING3-LABEL_GDT+SA_RPL3
	SelectorStack3 equ LABEL_DESC_STACK3-LABEL_GDT+SA_RPL3
	; ...
	; 定义堆栈段ring3
	[SECTION .s3]
	ALIGN 32
	[BITS 32]
	LABEL_STACK3:
		; 该堆栈段有512个字节大小
		times 512 db 0
	TopOfStack3 equ $-LABEL_STACK3-1
	; ...
	; 定义代码段ring3
	[SECTION .ring3]
	ALIGN 32
	[BITS 32]
	LABEL_CODE_RING3:
		mov ax, SelectorVideo
		mov gs, ax
		mov edi, (80*14 + 0) * 2
		mov ah, 0Ch
		mov al, '3'
		mov [gs:edi], ax
		jmp $
	SegCodeRing3Len equ $-LABEL_CODE_RING3
	; ...
	[SECTION .s32]
	[BITS 32]
	LABEL_SEG_CODE32:
		; ...
		; 压入ss
		push SelectorStack3
		; 压入esp
		push TopOfStack3
		; 压入cs
		push SelectorCodeRing3
		; 压入eip
		push 0
		; 执行ret指令
		retf
	\end{lstlisting}
\subsubsection{低特权级到高特权级}
	从低特权级到高特权级转移的时候，需要用到TSS，所以要添加TSS段。
	需要根据TSS的结构定义TSS，TSS的结构如下图:
	\fic{3.png}

	\begin{lstlisting}
	[SECTION .gdt]
	LABEL_DESC_TSS: Descriptor 0, TSSLen-1, DA_386TSS
	; ...
	SelectorTSS equ LABEL_DESC_TSS-LABEL_GDT
	; ...
	[SECTION .tss]
	ALIGN
	[BITS 32]
	LABEL_TSS:
		DD 0 ; 前一任务链接
		DD TopOfStack   ; 0级堆栈段基址
		DD SelectorStack ; 0级堆栈选择符
		DD 0 ; 1级堆栈段基址
		DD 0 ; 1级堆栈选择符
		DD 0 ; 2级堆栈段基址
		DD 0 ; 2级堆栈选择符
		DD 0 ; CR3
		DD 0 ; EIP
		DD 0 ; EFLAGS
		DD 0 ; EIP
		DD 0 ; EAX
		DD 0 ; ECX
		DD 0 ; EDX
		DD 0 ; EBX
		DD 0 ; ESP
		DD 0 ; EBP
		DD 0 ; ESI
		DD 0 ; EDI
		DD 0 ; ES
		DD 0 ; CS
		DD 0 ; SS
		DD 0 ; DS
		DD 0 ; FS
		DD 0 ; GS
		DD 0 ; LDT段选择符
		DW 0 ; 调试陷阱T标志位
		DW $-LABEL_TSS+2 ; I/O位图基址
		DB 0ffh ; I/O位图结束标志
	TSSLen equ $-LABEL_TSS
	\end{lstlisting}

	接着添加调用门，用于不同特权级的转移。调用门的添加步骤在第四次中已经讲到了，
	在这里就不再详细论述。添加调用门成功后，就可以在ring3代码段中通过调用门转移到特权级为0的代码段中。
	\begin{lstlisting}
	[SECTION .gdt]
	; ...
	; 定义一个特权级为0的代码段
	LABEL_DESC_CODE_TEST: Descriptor 0, SegCodeDestLen-1, DA_C+DA_32
	; 定义一个能够跳转到0特权级代码段的门描述符
	LABEL_CALL_GATE_TEST: Gate SelectorCodeDest, 0, 0, DA_386Gate+DA_DPL3
	; ...
	SelectorCallGateTest equ LABEL_CALL_GATE_TEST - LABEL_GDT

	; 在32位代码段中加载TSS描述符
	; 需要在特权级变换之前加载TSS描述符
	[SECTION .s32]
	; ...
	mov ax, SelectorTSS
	ltr ax
	; ...

	; 在ring3代码段中通过调用门跳转到特权级为0的代码段中
	[SECTION .ring3]
	ALIGN 32
	[BITS 32]
	LABEL_CODE_RING3:
		mov ax, SelectorVideo
		mov gs, ax
		mov edi, (80 * 14 + 0) * 2
		mov ah, 0Ch
		mov al, '3'
		mov [gs:edi], ax
		call SelectorCallGateTest:0
		jmp $
	SegCodeRing3Len equ $-LABEL_CODE_RING3
	\end{lstlisting}

\section{分页机制}
	分页机制的理论已经在第二次报告中提到了，这里就直接写代码实现吧。
\subsection{分页机制的实现}
\subsubsection{启动分页机制}
	代码中使用两极页表机制，第一级为页目录，大小为4KB，有1024个表项，每个表项对应一个第二级页表。
	第二级页表也有1024个表项，每个表项对应一个物理页。
	首先我会先初始化页目录，然后初始化每一个页表。之后，将页目录基址存放cr3中。然后将cr0的PG位置一，表示开启分页机制。
	我在第一次报告中提到过cr0和cr3，以下是它们的结构图。
	\fic{4.png}
	\fic{5.png}

	在代码中添加SetupPaging函数，用于启动分页机制。代码如下：
	\begin{lstlisting}
	; 页目录为4KB
	PageDirBase equ 200000h
	; 页表开始地址
	PageTblBase equ 201000h
	; ...
	; 在GDT表中添加页目录和页表的描述符
	[SECTION .gdt]
	LABEL_DESC_PAGE_DIR: Descriptor PageDirBase, 4095, DA_DRW
	LABEL_DESC_PAGE_TBL: Descriptor PageTblBase, 1023, DA_DRW | DA_LIMIT_4K
	; ...
	SelectorPageDir equ LABEL_DESC_PAGE_DIR - LABEL_GDT
	SelectorPageTbl equ LABEL_DESC_PAGE_TBL - LABEL_GDT
	; ...
	; 在32位代码段中添加SetupPaging函数，用于启动分页机制
	[SECTION .s32]
	[BITS 32]
	LABEL_SEG_CODE32:
		call SetupPaging
	SetupPaging:
		mov ax, SelectorPageDir
		mov es, ax
		mov ecx, 1024
		xor edi, edi
		xor eax, eax
		mov eax, PageTblBase | PG_P | PG_USU | PG_RWW
	.1:
		; 初始化页目录
		; 将页表的基地址存入页目录中
		; stosd的功能是将eax的内容移入到es所指的地址中
		stosd ; 每次edi会自动加一
		add eax, 4096 ; 一个页表的大小为4KB
		loop .1 ; 当计数寄存器为0时，结束循环

		; 初始化所有页表
		mov ax, SelectorPageTbl
		mov es, ax
		mov ecx, 1024 * 1024
		xor edi, edi
		xor eax, eax
		mov eax, PG_P | PG_USU | PG_RWW
	.2:
		stosd
		add eax, 4096 ; 每个表项指向一个4K的帧
		loop .2
		; 将页目录基地址存入cr3中
		mov eax, PageDirBase
		mov cr3, eax
		; 将cr0的最高位PG标志置一
		mov eax, cr0
		or eax, 80000000h
		mov cr0, eax
		jmp short .3
	.3:
		nop
		ret
	\end{lstlisting}

\subsubsection{利用分页机制节约内存}
	在上一节的代码中，虽然实现了代码，但是也暴露了两个问题：
	\begin{itemize}
		\item 分页机制确实是实现了，但是它没有带来实质性的好处。
		\item 页表占用的内存太大了。
	\end{itemize}

	在代码实现中，我用了4MB的空间用于存放页表，这些页表可以映射4GB的内存空间。
	假设现在的内存空间只有16MB大小，那么页表数根本不需要那么多，只需要4个就够了。
	所以，操作系统有必要知道内存的容量，从而进行内存管理。\par

	可以通过执行指令int 15h，来获得机器内存空间的大小。首先介绍一下int 15h指令。
	15h是中断向量号，进行软中断后，系统会根据eax寄存器的值执行相应的系统调用。
	下面相应的功能表，来源来自维基百科。
	\sizedfic{1}{6.png}
	
	该中断处理函数需要五个输入参数，如下：
	\begin{itemize}
		\item eax。根据上述的功能表可知，当eax = 0E820h时，中断函数将返回机器内存大小。
		\item ebx。ebx放置着"continuation value"，用于寻找下一个地址范围描述符结构ARDS。首次调用int 15h时，将ebx置为0。
		\item es:di。这个指向一个地址范围描述符结构ARDS。
		\item ecx。用于表示ARDS的大小，以字节为单位。
		\item edx。签名‘SMAP’，需要将edx设为0534D4150h，BIOS使用该签名对调用者将要请求的系统映像信息进行校验。
	\end{itemize}

	函数也有五个输出值，如下：
	\begin{itemize}
		\item CF。CF=0，表示没有发生错误。
		\item eax。存放着签名'SMAP'，0534D4150h。
		\item es:di。和输入值相同，指向一个地址范围描述符结构ARDS。
		\item ecx。BIOS会对ARDS进行信息填写，ecx中存放一个数值，这个数值代表了BIOS填写了ARDS多少字节。
		\item ebx。ebx放置着下一个地址描述符所需要的后续值。如果ebx的值为0，代表着当前的ARDS是最后一个地址范围描述符。
	\end{itemize}

	下图是地址范围描述符ARDS的数据结构：
	\fic{7.png}

	其中，Type的取值有三种情况：
	\begin{itemize}
		\item 1，表示这个内存段是一段可以被OS使用的RAM。
		\item 2，表示这个地址段正在被使用或者被系统保留，所以一定不可以被OS使用。
		\item 其他数，表示这个内存段被保留，留作以后使用，不可以被OS使用。
	\end{itemize}

	只能在实模式下使用int 15h，所以在16位代码段中添加相应地代码。将得到的内存空间信息写入缓冲区\_MemChkBuf中。下面是实现代码：
	\begin{lstlisting}
	_MemChkBuf: times 256 db 0
	_dwMCRNumber: dd 0
	; ...
	[SECTION .s16]
	[BITS 16]
		mov ebx, 0 ; 将ebx的值置为一
		mov di, _MemChkBuf ; 将内存信息写入缓冲区
	.loop:
		mov eax, 0E820h
		mov ecx, 20 ; 写入缓冲区的字节数
		mov edx, 0534D4150h
		int 15h
		jc LABEL_MEM_CHK_FAIL ; 检查CF标志
		add di, 20 ; 指向下一个内存信息写入地址
		inc dword [_dwMCRNumber]
		cmp ebx, 0 ; 检查是否为最后一个地址范围描述符
		jne .loop
		jmp LABEL_MEM_CHK_OK
	\end{lstlisting}

	现在内存信息都保存在缓冲区\_MemChkBuf中，需要有相应的代码计算其中的内存大小。
	为了实现这一功能，我定义了一个数据段。并且在32位代码中添加了CalMemSize函数用于计算内存大小。
	下面是实现代码：
	\begin{lstlisting}
	; 定义数据段
	[SECTION .data1]
	ALIGN 32
	[BITS 32]
	LABEL_DATA:
	_szRAMSize db "RAM size:", 0
	_dwMCRNumber: dd 0
	_dwMemSize: dd 0
	; 定义一个ARDS数据结构，大小为20字节
	_ARDSStruct:
		_dwBaseAddrLow: dd 0
		_dwBaseAddrHigh: dd 0
		_dwLengthLow: dd 0
		_dwLengthHigh: dd 0
		_dwType: dd 0
		
	szRAMSize equ _szRAMSize - $$
	dwMemSize equ _dwMemSize - $$
	dwMCRNumber equ _dwMCRNumber - $$
	ARDSStruct equ _ARDSStruct - $$
		dwBaseAddrLow equ _dwBaseAddrLow - $$
		dwBaseAddrHigh equ _dwBaseAddrHigh - $$
		dwLengthLow equ _dwLengthLow - $$
		dwLengthHigh equ _dwBaseAddrHigh - $$
		dwType equ _dwType - $$
	
	; 在32位代码中添加CalMemSize函数
	[SECTION .s32]
	[BITS 32]
	DispMemSize:
		mov ax, SelectorData
		mov ds, ax
		mov es, ax
		mov esi, MemChkBuf
		; mov [ds:dwMCRNumber] to ecx
		mov ecx, [dwMCRNumber]
	.loop:

		; 开始一个循环，将缓冲区中20字节读入ARDS结构中
		mov edx, 5
		; 将es:edi指向_ARDSStruct
		mov edi, ARDSStruct
	.1:
		mov eax, esi
		; 将eax移入[es:edi]，并将edi加4
		stosd
		add esi, 4
		dec edx
		cmp edx, 0
		jnz .1

		cmp dword [dwType], 1 ; 查看内存段的类型
		jne .2 ; 如果内存段可用，则跳转到.2
		mov eax, [dwBaseAddrLow]
		add eax, [dwLengthLow]
		cmp eax, [dwMemSize]
		jb .2
		; mov eax to [es:dwMemSize]
		mov [dwMemSize], eax
	.2:
		loop .loop
	\end{lstlisting}

	这里就能得到内存大小了，存储在dwMemSize中。随后根据内存大小计算应该初始化多少页目录项和页表项。
	下面是实现的代码：
	\begin{lstlisting}
	SetupPaging:
		xor edx, edx
		; eax存放着内存空间总大小
		mov eax, [dwMemSize]
		; ebx存放着一个页表对应的大小
		mov ebx, 40000h
		; div指令，eax除以ebx，商存储在eax中，余数存储在edx中
		div ebx
		; ecx中存放着商
		mov ecx, eax
		; 检查余数是否为0
		test edx, edx
		jz .no_remainder
		; 如果余数不为零，需要初始化的页表数加一
		inc ecx
	.no_remainder:
		push ecx
		; 虽然根据ecx中值的大小初始化页目录和页表
	\end{lstlisting}

\subsection{感受分页机制}
	由于分页机制的存在，程序使用的都是线性地址空间，而不再是物理地址。
	这样操作系统就为应用程序提供了一个不依赖于物理内存的平台，应用程序也不必关心实际上有多少物理内存，也不必关心正在使用的是哪一段内存，
	甚至不必关心某一个地址是在物理内存里面还是在硬盘中。\par
	首先说一下我想实现的功能。我定义了两个函数ProcPagingDemo和LinearAddrDemo，ProPagingDemo函数实现了向LinearAddrDemo这个线性地址的转移。
	一开始，我让LinearAddrDemo映射到物理地址空间中的ProcFoo处。虽然我切换页目录表和页表，让LinearAddrDemo映射到ProcBar这个物理地址上。\par
	程序一开始的时候，分页机制是默认物理地址等于线性地址的。这样我让LinearAddrDemo和ProcFoo的值相等，这样调用LinearAddrDemo时，就相当于调用ProcFoo处的代码。
	虽然分页机制将LinearAddrDemo映射到ProcBar，这样调用LinearAddrDemo时，就相当于调用ProcBar处的代码。\par
	\begin{lstlisting}
	LinearAddrDemo equ 00401000h
	ProcFoo equ 00401000h
	ProcBar equ 00501000h
	ProcPagingDemo equ 00301000h
	\end{lstlisting}

	为了将代码放置在ProcFoo和ProcBar这两个地方，还需要写两个函数，在程序运行时将这两个函数的执行代码复制过去。所以需要写一个复制函数MemCpy。
	实现代码如下：
	\begin{lstlisting}
	; void* MemCpy(void* es:pDest, void* ds:pSrc, int iSize);
	MemCpy:
		push ebp
		mov ebp, esp

		push esi
		push edi
		push ecx

		mov edi, [ebp + 8] ; pDest
		mov esi, [ebp + 12] ; pSrc
		mov ecx, [ebp + 16] ; iSize
	.1:
		cmp ecx, 0
		jz .2

		mov al, [ds:esi]
		inc esi

		mov byte [es:edi], al
		inc edi

		dec ecx
		jmp .1
	.2:
		mov eax, [ebp + 8]

		pop ecx
		pop edi
		pop esi
		mov esp, ebp
		pop ebp

		ret
	\end{lstlisting}

	这个代码是逐字节复制的，比较简单，就不详细说明了。需要注意的是，这个函数假设源数据存放在ds段中，目的地址在es段中，所以在调用这个函数之前，需要给ds和es赋值。
	而且这个函数需要三个参数，根据实现代码，需要将长度、源代码地址和目的地址压入栈中。需要注意的是，因为在调用函数之前压入了3个参数，一个参数的大小是4字节。
	为了在调用函数结束后跳过这三个参数，需要将esp指针的值加12。\par
	下面是相应的初始化代码：
	\begin{lstlisting}
	PagingDemo:
		mov ax, cs
		mov ds, ax
		mov ax, SelectorFlatRW
		mov es, ax

		push LenFoo
		push OffsetFoo
		push ProcFoo
		call MemCpy
		add esp, 12

		push LenBar
		push OffsetBar
		push ProcBar
		call MemCpy
		add esp, 12

		push LenPagingDemoAll
		push OffsetPagingDemoProc
		push ProcPagingDemo
		call MemCpy
		add esp, 12

	PagingDemoProc:
	OffsetPagingDemoProc equ PagingDemoProc - $$
		mov eax, LinearAddrDemo
		call eax
		retf
	LenPagingDemoAll equ $ - PagingDemoProc

	foo:
	OffsetFoo equ foo - $$
		mov ah, 0Ch
		mov al, 'F'
		mov [gs:((80 * 17 + 0) * 2)], ax
		mov al, 'o'
		mov [gs:((80 * 17 + 1) * 2)], ax
		mov [gs:((80 * 17 + 2) * 2)], ax
		ret
	LenFoo equ $ - foo
	
	bar:
	OffsetBar equ bar - $$
		mov ah, 0Ch
		mov al, 'B'
		mov [gs:((80 * 18 + 0) * 2)], ax
		mov al, 'o'
		mov [gs:((80 * 18 + 1) * 2)], ax
		mov [gs:((80 * 18 + 2) * 2)], ax
		ret
	LenBar equ $ - bar
	\end{lstlisting}

	所有初始化工作做好之后，就可以在分页机制下，通过调用ProcPagingDemo从而调用LinearAddrDemo线性地址处的代码。
	注意，LinearAddrDemo的值是00401000h。而分页机制中直接让线性地址等于物理地址。
	所以页表中偏移00401000h的位置指向的就是00401000h，也就是SelectorFlatRW:ProcFoo函数的地址。
	这样相当于调用ProcFoo处的代码。
	调用代码如下：
	\begin{lstlisting}
	; 通过分段机制得到相应的线性地址LinearAddrDemo
	; LinearAddrDemo为00401000h
	; 高10位为0000000001b，这样对应页目录中的第二个页表
	; 中间10位为000000000001b，这样对应页表中的第二个页
	; 一个页的大小是4k，一个页表就能指向4M的地址
	; 第二个页表的第二个页就是4M+4k，所以物理地址是00401000h
	; 所以LinearAddrDemo线性地址对应的代码是ProcFoo
	call SelectorFlatC:ProcPagingDemo
	\end{lstlisting}

	之后变换页表和页目录，让页表中偏移00401000h的位置指向的是00501000h，也就是ProcBar函数的地址。
	下面是切换页目录和页表的实现代码：
	\begin{lstlisting}
	PSwitch:
		mov ax, SelectorFlatRW
		mov es, ax
		mov edi, PageDirBase1
		xor eax, eax
		mov eax, PageTblBase1 | PG_P | PG_USU | PG_RWW
		mov ecx, [PageTableNumber]
	.1:
		stosd
		add eax, 4096
		loop .1

		mov eax, [PageTableNumber]
		mov ebx, 1024
		mul ebx
		mov ecx, ecx
		mov edi, PageTblBase1
		xor eax, eax
		mov eax, PG_P | PG_USU | PG_RWW
	.2:
		stosd
		add eax, 4096
		loop .2

		; 改变了LinearAddrDemo对应的物理地址
		; 处理LinearAddrDemo的高10位，也就是页目录的偏移量
		mov eax, LinearAddrDemo
		shr eax, 22
		mov ebx, 4096
		mul ebx 
		; ecx此时存放着相应页表的偏移字节
		mov ecx, eax

		; 处理LinearAddrDemo的中间10位，也就是页表的偏移量
		mov eax, LinearAddrDemo
		shr eax, 12
		and eax, 03FFh
		mov ebx, 4
		mul ebx ; eax此时存放着页表的偏移字节
		; 加上ecx后，eax此时存放着相应页的偏移字节
		add eax, ecx
		; 加上PageTblBase1，得到LinearAddrDemo所指的项
		add eax, PageTblBase1
		; 将该项的内容改为ProcBar的地址
		mov dword [es:eax], ProcBar | PG_P | PG_USC | PG_RWW

		; 改变cr3的值来切换页目录
		mov eax, PageDirBase1
		mov cr3, eax
		jmp short .3
	.3:
		nop
		ret
	\end{lstlisting}

	改变后，线性地址LinearAddrDemo对应的物理地址是ProcBar。
	再次调用SelectorFlatC:ProcPagingDemo，就会调用ProcBar函数。

\clearpage

\section{学习Java}
	因为最近参加了挑战杯，所以需要使用android编程。之前我使用的都是C$\backslash$C++，所以对Java不是很了解。
	以后在学习报告中，除了操作系统的内容，还会添加Java学习的内容。

\subsection{第一个Java程序}
\subsubsection{名字管理}
	Java为了给一个类库生成不会与其他名字混淆的名字，让程序员反过来使用自己的Internet域名，从而保证它们是独一无二的。
	比如域名为MindView.net，那么各种应用工具库就被命名为net.mindview.utility.foibles。
	反转域名后，句点就用来代表子目录的划分。\par
\subsubsection{static关键字}
	现在有两个需求，如下所示：
	\begin{itemize}
		\item 只想为某个特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。
		\item 希望某个函数不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也可以调用这个函数。
	\end{itemize}

	static关键字可以满足这两方面的需求。当声明一个事物是static的时候，就意味着这个域或这个函数不会与包含它的那个类的任何对象实例关联在一起。\par
	引用static变量有两种方法。可以通过一个对象去定位它，也可以通过其类名直接引用。\par
	static函数的重要用法是在不创建任何对象的前提下就可以调用它。
\subsubsection{Hello world}
	下面是第一个完整的程序，可以打印出“hello world”：
	\begin{lstlisting}[language = Java]
	import java.util.*;

	public class HelloWorld
	{
		public static void main(String[] args)
		{
			System.out.println("hello world");
		}
	}
	\end{lstlisting}
\subsubsection{编码风格}
	代码风格的规定如下：
	\begin{itemize}
		\item 类名的首字母要大些。如果类名由几个单词构成，那么就把它们并在一起，其中每个内部单词的首字母都采用大写形式。
		\item 其他内容，第一个字母采用小写。如果该内容由几个单词构成，那么就把它们并在一起，其中每个内部单词的首字母都采用大写形式。
	\end{itemize}

% \subsection{初始化与清理}

\end{document}
