% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=[x86masm]Assembler,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{第四次学习报告 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\section{系统调用}
	虽然在第一次报告中提到过系统调用，但是由于当时自己了解地不够全面，所以这次重新完整地学习系统调用。
\subsection{系统调用的过程}
	用户空间的程序无法直接执行内容代码，也就无法直接调用内核空间中的函数。系统通过以下方式实现系统调用。
	\begin{itemize}
		\item 应用程序以软中断的方式通知内核自己需要一个系统调用。\par
			  在x86上，软中断的中断向量号为128，所以可以通过int \$0x80指令触发软中断。
			  int \$0x80之后，系统切换到内核态，并执行第128号异常处理程序system\_call()。这个程序在entry\_64.S文件中用汇编语言编写。
		\item 内核代表应用程序在内核空间执行系统调用。\par
			  在陷入内核前，应用程序将相应的系统调用号放入eax中，当系统调用处理程序运行时，可能直接从eax中得到数据。在执行相应的系统调用前，需要验证系统调用号的有效性。实现代码如下。
			  \begin{lstlisting}
	cmpl $__NR_syscall_max, %eax
	ja 1f ; 如果系统调用号大于__NR_syscall_max，则返回-ENOSYS
			  \end{lstlisting}
			  如果系统调用号有效，就执行系统调用表中相应的系统调用。
			  \begin{lstlisting}
	; %rax存放着系统调用号
	; 因为是64位系统，系统调用表中的表项是以8字节类型存放的，所以需要将给定的系统调用号乘以8
	call *sys_call_table(,%rax,8)
			  \end{lstlisting}
	\end{itemize}

	上述过程只是讲述了内核空间如何执行系统调用。除此之外，还需要明白应用程序在用户空间是怎么以软中断的方式通知内核自己需要一个系统调用。\par
	Linux在unistd.h中提供了一组宏，用于直接对系统调用进行访问。这组宏可以设置好寄存器并调用陷入指令。实现代码如下。
	\begin{lstlisting}[language=C]
	#define _syscall0(type, name) \
	type name(void) \
	{\
		long __res; \
		__asm__ volatile(
			"int $0x80" \
			: "=a" (__res)
			: "0" (__NR_##name)); \
		if(__res >= 0) \
			return (type) __res; \
		errno = -__res; \
		return -1;\
	}
	\end{lstlisting}

	假设现在有一个系统调用foo()，我们就可以用下面的方式在用户空间调用它。
	\begin{lstlisting}[language=C]
	__syscall0(long, foo)
	// 这里的宏会展开为 long foo(){/*...*/}

	int main()
	{
		// ...
		foo();
		//...
		return 0;
	}
	\end{lstlisting}

	需要注意的是，系统不只拥有\_syscall0()这一个宏，它提供了一组宏，这组宏是\_syscalln()。这里的n代表了需要传递给系统调用的参数个数。
	宏所需要的参数个数是2+2n，第一个参数是系统调用函数返回类型，第二个参数是系统调用名称，随后是系统调用每个参数的类型和名称。

\subsection{注册系统调用的步骤}
	下面通过将foo()加入为系统调用来说明这个步骤。
\begin{itemize}
	\item 首先，需要在系统调用表的最后加入一个表项。现在要把foo()注册为一个正式的系统调用，就要把sys\_foo加入到系统调用表中。实现代码如下：
	\begin{lstlisting}
	ENTRY(sys_call_table)
		.long sys_restart_syscall
		;...
		.long sys_perf_event_open ; 最后一项
		; 将sys_foo加到这个表的末尾
		.long sys_foo
	\end{lstlisting}

	因为我对linux汇编还不是很熟悉，所以去查询了以下几条指令的意思：
	\begin{lstlisting}
	ENTRY()
	; 这是一个宏，定义于linux-2.6.35.5/include/Linux/linkage.h。格式如下：
	#define ENTRY(name) \
	.globl name \
	ALIGN \
	name:

	; .globl symbol 的含义是：
	; 定义该symbol为global的，也就是其他文件可以访问并使用该symbol

	; .long val 的含义是：
	; 该指令在当前区定义一个32位长整数的常数。需要注意该指令无法在bss段中使用
	\end{lstlisting}

	\item 接下来，将foo()的系统调用号加到<arch/arm/include/uapi/asm/unistd.h>中。实现代码如下：
	\begin{lstlisting}[language=C]
	#if defined(__thumb) || defined(__ARM_EABI)
	#define __NR_SYSCALL_BASE 0
	#else
	#define __NR_SYSCALL_BASE __NR_OABI_SYSCALL_BASE
	#endif

	#define __NR_restart_syscall (__NR_SYSCALL_BASE + 0)
	// ...
	// 最后一个系统调用号
	#define __NR_pkey_free (__NR_SYSCALL_BASE + 396)
	// 在最后一行添加foo()的系统调用号
	#define __NR_foo (__NR_SYSCALL_BASE + 397)
	\end{lstlisting}

	\item 最后在内核代码中定义这个系统调用函数。
	\begin{lstlisting}[language=C]
	asmlinkage long sys_foo()
	{
		return THREAD_SIZE;
	}

	// asmlinkage在linkage.h中有定义
	#ifdef CONFIG_X86_32
	#define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))
	#endif
	// __attribute__((regparm(0)))告诉编译器参数只能通过堆栈来传递
	// X86里面的系统调用都是先将参数压入stack以后调用sys_*函数的，所以必须告诉编译器只能通过堆栈传递参数
	\end{lstlisting}
\end{itemize}
\subsection{学习系统调用后的反思}
	在前面几个小节，我学会了如何在操作系统中新建一个系统调用。这一开始让我兴奋，随后而来的是疑惑，
	因为我并不了解系统是如何支持系统调用这个行为的。我也不了解int \$0x80之后，系统具体发生了什么。
	我觉得这还需要我学习了系统的中断机制和特权保护机制后，知道如何去实现它们后，才能真正地理解系统调用。

\clearpage

\section{LDT的实现}
\subsection{LDT的定义}
	首先我们需要在GDT表中增加局部描述符表的描述符。
	\begin{lstlisting}
		[SECTION .gdt]
		LABEL_GDT: Descriptor 0,LDT
		; 添加的描述符
		LABEL_DESC_LDT: Descriptor 0,LDTLen-1,DA_LDT
		; 相应的选择符
		SelectorLDT equ LABEL_DESC_LDT - LABEL_GDT
	\end{lstlisting}
	
	然后我们需要定义一个LDT表。LDT表和GDT表其实很类似，我在其中定义了一个指向CODEA代码段的段描述符。
	\begin{lstlisting}
		; 定义LDT表
		[SECTION .ldt]
		ALIGN 32
		LABEL_LDT:
		LABEL_LDT_DESC_CODEA: Descriptor 0,CodeALen-1,DA_C+DA_32
		LDTLEN equ $-LABEL_LDT
		
		SelectorLDTCodeA equ LABEL_LDT_DESC_CODEA-LABEL_LDT+4
		LDTLen equ $-LABEL_LDT
		
		; 定义在LDT表中段描述符指向的代码段
		[SECTION .la]
		ALIGN 32
		[BITS 32]
		LABEL_CODE_A:
			mov ax,SelectorVideo
			mov gs,ax
			mov edi,(80*12+0)*2
			mov ah,0Ch
			mov al,'L'
			mov [gs:edi],ax
		CodeALen equ $-LABEL_CODE_A
	\end{lstlisting}
	
	上面代码段中，我们应该注意的是这个语句。
	\begin{lstlisting}
		SelectorLDTCodeA equ LABEL_LDT_DESC_CODEA-LABEL_LDT+4
	\end{lstlisting}
	
	这个选择符的定义和GDT选择符的定义有不同。在解释为什么这么写之前，我想重新说一下自己对段选择符的认识。因为在第二次学习报告中，我对它的描述实在过于粗糙。\par
	段选择符是段的一个16位标志符。段选择符并不直接指向段，而是指向段描述符表中定义段的段描述符。段选择符的结构如下图。
	\fic{1.png}
	从图中可以看出，段选择符有3个字段内容：
	\begin{itemize}
		\item 请求特权级RPL。RPL被用于特权级保护机制中。
		\item 表指示标志TI。当TI=0时，表示描述符在GDT中。当TI=1时，表示描述符在LDT中。因为一个任务执行时，可以同时访问到LDT和GDT，所以必须做这样的区别，以防在索引时放生混淆。
		\item 索引值。用于索引在GDT表或LDT表中的段描述符。
	\end{itemize}
	
	\begin{lstlisting}
		; 这里特意加4，就是为了将段选择符中的第2位TI标志置一
		SelectorLDTCodeA equ LABEL_LDT_DESC_CODEA-LABEL_LDT+4
	\end{lstlisting}
\subsection{LDT的初始化}
	需要注意的是，既然在GDT表中添加了指向LDT表的段描述符，就应该在16位代码段中初始化它。
	\begin{lstlisting}
		[SECTION .16]
		[BITS 16]
			
			; 初始化LDT在GDT中的描述符
			xor eax,eax
			mov ax,ds
			shl eax,4
			add eax,LABEL_LDT
			mov word [LABEL_DESC_LDT + 2], ax
			shr eax,16
			mov byte [LABEL_DESC_LDT + 4], al
			mov byte [LABEL_DESC_LDT + 7], ah
	\end{lstlisting}
	
	LDT表和GDT表区别仅仅在于全局和局部的不同，所以初始化LDT表中描述符和之前的操作很类似。具体情况看下面的代码。
	\begin{lstlisting}
		[SECTION .16]
		[BITS 16]
			; 初始化LDT表中的描述符
			xor eax,eax
			mov ax,ds
			shl eax,4
			add eax,LABEL_CODE_A
			mov word [LABEL_LDT_DESC_CODEA + 2], ax
			shr eax,16
			mov byte [LABEL_LDT_DESC_CODEA + 4], al
			mov byte [LABEL_LDT_DESC_CODEA + 7], ah
	\end{lstlisting}
\subsection{调用LDT中的代码段}
	\begin{lstlisting}
		[SECTION .s32]
		[BITS 32]
			; 将LDT表的段选择符加载进LDTR寄存器中
			; 在LDTR寄存器中的LDT段描述符存放着LDT表的基址
			; 对LDT表中的代码段描述符进行寻址时，以LDTR中LDT表的描述符中的基址为准
			; 偏移量由段选择符制定，用于索引LDT表中存放着的代码段描述符
			; 当发生任务切换时，LDTR会更换新任务的LDT
			mov ax,SelectorLDT
			lldt ax
			; CPU根据代码段描述符中的TI标志判断是索引GDT表还是索引LDT表
			jmp SelectorLDTCodeA:0
	\end{lstlisting}
\subsection{总结如何添加LDT表}
	\begin{itemize}
		\item 添加一个LDT表，里面可以类似于GDT表，存放代码段、数据段或堆栈段。
		\item 在GDT表中添加新LDT表的段描述符。
		\item 在16位代码段中初始化新LDT表的段描述符。同时初始化LDT表中存放着的所有段描述符。
	\end{itemize}

\clearpage

\section{保护机制的实现}
\subsection{保护机制的相关介绍}
	虽然我在第二次学习报告中也提到了保护机制，但是过于粗糙。我自己感觉对它的认识也不够深入，所以在这里重新整理一下对保护机制的认识。\par
\subsubsection{段级保护}
	段限长检查。段描述符的段限长字段用于防止程序寻址到段外内存位置。当G=0时，段限长最大为1MB。当G=1时，段限长最大为4GB。
	除了检查段限长，处理器也会检查描述符表的长度。GDTR、IDTR和LDTR寄存器都包含有描述符的限长值，用于防止程序在描述符表的外面选择描述符。\par
	段类型检查。段描述符中有S标志和TYPE字段用于标识段的类型。S=1时，为系统类型的段。S=0时，为代码或数据类型的段。
	TYPE字段的4个比特位用于定义代码、数据和系统描述符的各种类型。处理器在以下两种情况会检查段的类型信息：
	\begin{itemize}
		\item 当段选择符加载进一个段寄存器时需要检查段的类型，因为某些段寄存器只能存放特定类型的描述符。
		\item 一些指令操作不被允许在某些类型的段上执行。比如任何指令不能写一个可执行段。
	\end{itemize}

	特权级检查。段保护机制有4个特权级，由段描述符的DPL字段中定义。另外还需要知道，CPL是当前任务的特权级，RPL是段描述符的特权级。
	特权级检查可以分为3种情况。
	\begin{itemize}
		\item 访问数据段时的特权级检查。\par
			  为了访问数据段中的操作数，数据段中的段选择符需要加载进数据段寄存器或堆栈寄存器中，此时就需要特权级检查。
			  处理器会比较CPL、RPL和DPL，只有当DPL的数值大等于CPL和RPL两者时，处理器才会把选择符加载进段寄存器，否则就会产生一个一般保护异常。
			  需要注意的是，当使用堆栈选择符加载SS段寄存器时，DPL、RPL和CPL都需要相同，否则就会产生一个一般保护异常。
		\item 直接调用或跳转到代码段时的特权级检查。\par
			  首先说明一下一致代码段与非一致代码段的概念。一致代码段允许当前特权级任务跳转到更高特权级的代码段，并且当前任务的CPL也会设置为更高特权级代码段的DPL值。
			  而非一致代码段不允许这样的行为。段描述符中的C标志用于标识一致代码段和非一致代码段。C=1时，为一致代码段。C=0时，为非一致代码段。
			  需要注意的是，一致代码段和非一致代码段都不允许当前任务跳转到更低特权级的代码段。\par
			  当访问一致代码段时，处理器会忽略对RPL的检查，只要求CPL大等于DPL。当访问非一致代码段时，CPL必须等于DPL，而RPL必须小等于DPL。
		\item 通过调用门访问代码段时的特权级检查。\par
			  因为处理器通过调用门描述符去访问代码段描述符，所以还需要对调用门描述符进行特权级检查。处理器要求CPL和RPL都要小于调用门描述符的DPL。
			  随后进行对代码段的特权级检查。当使用CALL指令时，对于一致代码段和非一致代码段都只要求DPL小等于CPL。
			  当使用JMP指令时，对于一致代码段要求DPL小等于CPL，对于非一致代码段要求DPL等于CPL。
	\end{itemize}

\subsubsection{页级保护}
	只有当所有的段级保护通过后，才会进行页级保护检查。\par
	页级保护分为两类权限，分别为超级用户级和普通用户级。特权级0、1、2的任务被归类为超级用户级，特权级3的任务被归类为普通用户级。
	页面也分为超级用户级和普通用户级。页目录和页表项中的U/S标志用于标识该页面的级别。只有当两者的U/S都为0，页面才是超级用户级，否则是普通用户级。
	普通用户级的程序不可访问超级用户级的页面，超级用户级的程序可以读/写/执行所有页面。\par
	普通用户级的程序只能访问普通用户级的页面，但是不一定可以写。只有当页面和页目录的读写标志R/W都为1时，普通用户级的程序才能写普通用户级的页面。

\subsection{编写保护机制}
	在编写保护机制前，我觉得有必要先把段描述符的属性搞清楚。先来回忆一下段描述符的格式，如下图。
	\fic{2.png}
	
	可以清楚地看到，描述符的第6和第7个字节是属性与段限长的混合。对这16位进行赋值。假设有20位的段限长，首先给描述符低16位的段限长赋值，代码为LEN \& 0FFFFh。
	然后将其右移8位，剩12位，最后取剩余的12位的高4位，并对第7字节中的段限长字段赋值。代码为((LEN >> 8) \& 0F00h)。
	现在第6和第7字节仅剩属性还未赋值，代码为 ATTR \& 0F0FFh。
	现在重温一下段描述符的数据结构，我觉得现在对这个数据结构的理解完全掌握了。
	\begin{lstlisting}
	%marco Descriptor 3
		dw %2 & 0FFFFh
		dw %1 & 0FFFFh
		dw (%1 >> 16) & 0FFh
		dw ((%2 >> 8) & 0F00h) | (%3 & 0F0FFh)
		db (%1 >> 24) & 0FFh
	%endmarco
	\end{lstlisting}

\subsubsection{对段描述符属性的编程}
	根据宏定义，段的属性由第三个参数决定。下面定义一些宏，用于定义段的属性。在代码中我会注释为什么这么定义宏。
	\begin{lstlisting}
	; 第三个参数的高4位分别为G、D/B、保留比特位和AVL位。
	; 4h=0100b，相当于将D/B设置为1。
	; 对于代码段，这个标志用于指出该段中的指令引用有效地址和操作数的默认长度。
	; D/B为1时，有效地址为32位，操作数长度为32位或8位。
	; D/B为0时，有效地址为16位，操作数长度为16位或8位。
	; DA_32代表段为32位段
	DA_32 EQU 4000h

	; 第三参数的低8位为P、DPL、S和TYPE。
	; P表示段是否存在在内存中
	; DPL表示段描述符的特权级
	; S表示该段是系统段描述符或门描述符还是代码或数据段

	; 给出存储段描述符的属性

	; TYPE有4位，最高位为0时，为数据段，最高位为1时，为代码段。
	; 为数据段时，TYPE为0、E(扩展方向)、W(可写)和A(已访问)。
	; 为代码段时，TYPE为1、C(一致性)、R(可读)和A(已访问)。
	; 后面会有一张表，用于整理TYPE的各种情况。

	; 数据段
	DA_DR EQU 90h ; 存在的只读数据段
	DA_DRA EQU 91h ; 存在的已访问只读数据段 
	DA_DRW EQU 92h ; 存在的可读写数据段
	DA_DRWA EQU 93h ; 存在的已访问的可读写数据段
	DA_C EQU 98h ; 存在的仅执行代码段

	; 代码段
	DA_CA EQU 99h ; 存在的已访问的仅执行代码段
	DA_CR EQU 9Ah ; 存在的可执行可读代码段
	DA_CCO EQU 9Ch ; 存在的可执行的一致代码段
	DA_CCOR EQU 9Eh ; 存在的可执行的可读一致代码段

	; 给出系统段描述符的属性

	; 此时TYPE有16种情况，除了3个保留情况以外，有13种段描述符
	; 后面会有一张表，用于整理系统段描述符的各种情况

	DA_LDT EQU 82h ; LDT表描述符
	DA_TaskGate EQU 85h ; 任务门描述符
	DA_386TSS EQU 89h ; 32位TSS描述符
	DA_386CGate EQU 8Ch ; 32位调用门描述符
	DA_386IGate EQU 8Eh ; 32位中断门描述符
	DA_386TGate EQU 8Fh ; 32位陷阱门描述符
	\end{lstlisting}

	下面是各种类型的代码段描述符和数据段描述符。
	\fic{3.png}

	\clearpage

	下面是各种类型的系统段描述符和门描述符。
	\fic{4.png}

	到此，我自认为自己对段描述符是理解得比较透彻了。接下来进行对段选择符的编程。

\subsubsection{对段选择符属性的编程}
	段选择符相对于段描述符而言简单很多，因为它只由三部分组成，分别是描述符索引、TI标志和RPL标志。
	TI标志表示段描述符在GDT中还是在LDT中。RPL标志用于表示段选择符的请求特权级。
	段选择符的结构如下图。
	\fic{5.png}

	下面是实现代码。
	\begin{lstlisting}
	; 用于设置TI位
	SA_TIG EQU 0
	SA_TIL EQU 4

	; 用于设置RPL字段
	SA_RPL0 EQU 0
	SA_RPL1 EQU 1
	SA_RPL2 EQU 2
	SA_RPL3 EQU 3
	\end{lstlisting}

\subsubsection{小结}
	有了对段描述符、段选择符的属性编程，x86的保护机制也就可以实现了。

\clearpage

\section{调用门的实现}
	虽然处理器可以通过jmp或call直接进行转移，但是这样所能进行的代码段间转移是非常有限的。对于非一致代码段，只能在相同特权级代码段之间转移。
	对于一致代码段，也最多从低特权级代码段向高特权级代码段进行转移。如果想自由地进行不同特权级之间的转移，则需要门描述符或TSS。\par
	首先看一下门描述符的结构，见下图。
	\fic{6.png}

	有了对段描述符的编程经历，门描述符的编程就变得简单很多了。它的数据结构代码和段描述符有相似之处。
	\begin{lstlisting}
	%marco Gate 4
		dw %2 & 0FFFFh
		dw %1
		db (%3 & 1Fh) | ((%4 << 8) & 0FF00h)
		dw (%2 >> 16) & 0FFFFh
	%endmarco
	\end{lstlisting}

\subsection{添加门描述符}
\subsubsection{定义门描述符}
	首先在GDT表中添加门描述符。
	\begin{lstlisting}
	[SECTION .gdt]
	LABEL_GDT: Descriptor 0, 0, 0
	LABEL_DESC_CODE: Descriptor 0, SegCodeDestLen-1, DA_C + DA_32
	; ...
	; 这里的SelctorCodeDest，是指向LABEL_DESC_CODE段描述符的
	; 门描述符的特点就是间接调用代码段
	LABEL_CALL_GATE_TEST: Gate SelectorCodeDest, 0, 0, DA_386CGate + DA_DPL0
	; ...
	SelectorCodeDest equ LABEL_DESC_CODE - LABEL_GDT
	SelectorCallGateTest equ LABEL_CALL_GATE_TEST - LABEL_GDT
	\end{lstlisting}

	我发现自己有个东西忘记交代了，就是GDT表的第一个描述符是空描述符，所有总是有
	\begin{lstlisting}
	LABEL_GDT: Descriptor 0, 0, 0
	\end{lstlisting}

\subsubsection{初始化门描述符}
	门描述符不像段描述符一样拥有段基址，所以在定义门描述符时即可完成初始化，也就不用在16位代码段中另外初始化门描述了。

\subsubsection{使用门描述符}
	

\end{document}
