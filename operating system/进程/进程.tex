% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{report}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
% \renewcommand\refname{参考文献}
% \renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=C,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

\newcommand{\tablestart}{
	\interval
	\begin{longtable}{p{2cm}p{10cm}}
	\hline}
\newcommand{\tableend}{
	\hline
	\end{longtable}
	\interval}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{进程 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\chapter{进程}
\section{形成进程的必要考虑}
	CPU的个数通常总是小于进程的个数，所以我们需要进程调度，使得系统总有“正在运行的”和“正在休息的”进程。\par

	为了让“正在休息的”进程在重新醒来时记住自己挂起之前的状态，我们需要一个数据结构记录一个进程的状态。\par

	还需要考虑的是，进程和进程切换运行在不同层级上。\par

	还有一点需要考虑，就是进程自己不知道什么时候被挂起，什么时候又被启动，我们需要知道诱发进程切换的原因不只一种，比如发生了时钟中断。

\section{最简单的进程}
	首先介绍一下进程切换的情形：
	\begin{lstlisting}
	一个进程正在运行着，此时时钟中断发生。
	特权级从ring1跳到ring0，开始执行时钟中断处理程序。
	中断处理程序调用进程调度模块，指定下一个应该运行的进程。
	中断处理程序结束时，下一个进程准备就绪并开始运行，特权级从ring0跳回ring1。
	\end{lstlisting}

	从上述过程得知，我们需要完成几个部分：
	\begin{itemize}
		\item[1.] 时钟中断处理程序。
		\item[2.] 进程调度模块。
		\item[3.] 两个进程。
	\end{itemize}

\subsection{简单进程中的关键技术}
\subsubsection{进程状态的保存}
	需要考虑保存进程的状态，用于恢复进程，所以我们要把寄存器的值统统保存起来。\par
	
	一般使用push或pushad保存大多寄存器的值，并且把它写在时钟中断例程的最顶端，以便中断发生时马上被执行。\par

	当恢复进程时，使用pop来恢复寄存器的值，虽然执行指令iretd回到原先的进程。

\subsubsection{进程表PCB}
	之前已经提到过，我们需要一个数据结构记录一个进程的状态。这个数据结构叫做进程表，也就是进程控制块PCB。\par

	进程表是用来描述进程的，所以它必须独立于进程之外。每个进程有一个对应的进程表，我们会有很多个进程，所以就需要创建一个进程表数组。

\subsubsection{进程栈和内核栈}
	在进程切换时，我们需要考虑esp指向的位置。\par

	当进程运行时，esp指向进程堆栈中的某个位置。而为了把进程的寄存器状态压进进程表，esp此时又需要指向进程表的某个位置。\par

	需要知道的是，中断处理程序也可能用到堆栈操作，而显然我们不能容忍esp对进程表进行操作，所以我们应该让esp指向专门的内核栈区域。\par

	总而言之，进程切换过程中，esp将出现在3个不同的区域，如下图所示：
	\fic{1.png}

	这三个区域的描述如下：
	\begin{itemize}
		\item 进程栈，进程运行时自身的堆栈。
		\item 进程表，存储进程状态信息的数据结构。
		\item 内核栈，进程调度模块运行时使用的堆栈。
	\end{itemize}

\subsubsection{特权级变换}
	系统原先运行在ring0，所以当我们准备开始第一个进程时，我们面临一个ring0向ring1的转移。\par

	这个过程和恢复进程很相似，所以我们通过假装发生了一次时钟中断来启动第一个进程，利用iretd来实现ring0向ring1的转移。\par

	当执行时钟中断处理程序时，需要从ring1向ring0转移，此时要从当前TSS中取出内层ss和esp作为目标代码的ss和esp，所以我们必须事先准备好TSS。\par

	因为每个进程相对独立，所以这些任务状态段相互独立。我们需要把涉及到的描述符放在局部描述符表LDT中，这意味着我们还需要为每个进程准备LDT。

\section{从ring0到ring1}
\subsection{时钟中断处理程序}
	如果想实现从ring0到ring1的转移，只需要用一个iretd指令。\par

	我们的时钟中断处理程序如下：
	\begin{lstlisting}
	ALIGN 16
	hwint00:
		iretd
	\end{lstlisting}

\subsection{进程表、进程体、GDT、TSS}
	一个进程开始之前，我们必须初始化cs、ds、es、fs、gs、ss、esp、eip、eflags，才能让一个进程正常运行。\par

	其中，cs、ds、fs、es这些段寄存器对应的是LDT中的描述符，所以我们还要初始化局部描述符表。
	因为LDT本身是进程的一部分，所以需要把它放在进程表中，并且还需要在GDT中增加相应的描述符，对应的选择子将被加载给ldtr。\par

	因为每个进程都有一个任务状态段，所以我们必须初始化一个TSS，并且在GDT中增加相应的描述符，对应的选择子将被加载给tr。
	目前，TSS中我们只会用到ss和esp，所以我们只初始化它们两个。\par

	gs指向显存的描述符，用于访问显存。\par

	根据上述描述，各寄存器和GDT、LDT、TSS的关系如下图：
	\fic{2.png}
	
\subsection{一个简单的进程执行体}
	我们的第一个进程执行体如下：
	\begin{lstlisting}
	// 位于main.c文件
	void TestA()
	{
		int i = 0;
		while(1)
		{
			disp_str("A");
			disp_int(i++);
			disp_str(".");
			delay(1);
		}
	}

	// delay()函数放置在klib.c文件中
	PUBLIC void delay(int time)
	{
		int i, j, k;
		for(k = 0; k < time; k++)
		{
			for(i = 0; i < 10; i++)
			{
				for(j = 0; j < 10000; j++){}
			}
		}
	}
	\end{lstlisting}

	这里，我们为了等待中断的发生，我们将在重新放置堆栈和GDT表之后，将跳转到一个kernel\_main()函数：
	\begin{lstlisting}
	// 位于main.c文件
	PUBLIC int kernel_main()
	{
		disp_str("----\"kernel_main\" begins----\n");
		while(1){}
	}

	// 修改kernel.asm文件
	extern kernel_main
		...
		jmp kernel_main
	\end{lstlisting}

\subsection{定义进程表}
	进程表就是存储进程状态信息的数据结构，在这之前我们还要定义栈帧和进程结构体。

\subsubsection{定义栈帧}
	\begin{lstlisting}
	// 位于proc.h文件
	typedef struct s_stackframe
	{
		// gs、fs、es、ds、edi、esi、ebp、kernel_esp、ebx、edx、ecx、eax将被save()函数压栈
		u32 gs;
		u32 fs;
		u32 es;
		u32 ds;
		u32 edi;
		u32 esi;
		u32 ebp;
		u32 kernel_esp;
		u32 ebx;
		u32 edx;
		u32 ecx;
		u32 eax;

		u32 retaddr; // 暂时不知道它有什么用

		// 在中断发生时将被CPU压栈
		u32 eip;
		u32 cs;
		u32 eflags;
		u32 esp;
		u32 ss;
	}STACK_FRAME;
	\end{lstlisting}

\subsubsection{定义进程结构体}
	根据之前的总结，我们知道，一个进程，拥有进程表、LDT、指向LDT的选择子、进程号和进程名。所以它的代码定义如下：
	\begin{lstlisting}
	// 位于proc.h文件
	typedef struct s_proc
	{
		STACK_FRAME regs;
		u16 ldt_sel;
		DESCRIPTOR ldts[LDT_SIZE];
		u32 pid;
		char p_name[16];
	}PROCESS;
	\end{lstlisting}

\subsubsection{初始化进程表}
	进程表就是进程结构体的数组：
	\begin{lstlisting}
	// 位于global.c文件
	PUBLIC PROCESS proc_table[NR_TASKS];
	\end{lstlisting}

	初始化进程表的代码如下：
	\begin{lstlisting}
	PROCESS* p_proc = proc_table;

	// 初始化ldt_sel
	p_proc->ldt_sel = SELECTOR_LDT_FIRST;

	// 初始化ldts[LDT_SIZE]
	memcpy(&p_proc->ldts[0], &gdt[SELECTOR_KERNEL_CS>>3], sizeof(DESCRIPTOR));
	p_proc->ldts[0].attr1 = DA_C | PRIVILEGE_TASK << 5;
	memcpy(&p_proc->ldts[1], &gdt[SELECTOR_KERNEL_DS>>3], sizeof(DESCRIPTOR));
	p_proc->ldts[1].attr1 = DA_DRW | PRIVILEGE_TASK << 5;

	// 初始化栈帧regs中的寄存器
	// cs指向LDT中第一个描述符
	p_proc->regs.cs = (0 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	// ds、es、fs、ss指向LDT中的第二个描述符
	p_proc->regs.ds = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	p_proc->regs.es = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	p_proc->regs.fs = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	p_proc->regs.ss = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	// gs指向显存
	p_proc->regs.gs = (SELECTOR_KERNEL_GS & SA_RPL_MASK) | RPL_TASK;
	// eip指向TestA，进程将从TestA的入口地址开始运行
	p_proc->regs.eip = (u32)TestA;
	// esp指向了单独的栈
	p_proc->regs.esp = (u32)task_stack + TASK_SIZE_TOTAL;
	// 将IOPL位设为1，让进程可以使用I/O指令
	p_proc->regs.eflags = 0x1202;
	\end{lstlisting}

	上述代码中的宏定义于protect.h中：
	\begin{lstlisting}
	#define INDEX_DUMMY 0
	#define INDEX_FLAT_C 1
	#define INDEX_FLAT_RW 2
	#define INDEX_VIDEO 3
	#define INDEX_TSS 4
	#define INDEX_LDT_FIRST 5

	#define SELECTOR_DUMMY 0
	#define SELECTOR_FLAT_C 0x08
	#define SELECTOR_FLAT_RW 0x10
	#define SELECTOR_VIDEO (0x18 + 3)
	#define SELECTOR_TSS 0x20
	#define SELECTOR_LDT_FIRST 0x28

	#define SELECTOR_KERNEL_CS SELECTOR_FLAT_C
	#define SELECTOR_KERNEL_DS SELECTOR_FLAT_RW
	#define SELECTOR_KERNEL_GS SELECTOR_VIDEO

	// 每个任务有一个单独的LDT
	#define LDT_SIZE 2

	#define SA_RPL_MASK 0xFFFC
	#define SA_RPL0 0
	#define SA_RPL1 1
	#define SA_RPL2 2
	#define SA_RPL3 3

	#define SA_TI_MASK 0xFFFB
	#define SA_TIG 0
	#define SA_TIL 4
	\end{lstlisting}

\subsection{初始化GDT表中的LDT描述符}
	进程拥有LDT表，而GDT中需要有进程的LDT的描述符，所有我们还需要初始化GDT中进程LDT的描述符：
	\begin{lstlisting}
	// 位于proctect.h
	init_descriptor(&gdt[INDEX_LDT_FIRST], vir2phys(seg2phys(SELECTOR_KERNEL_DS), proc_table[0].ldts), LDT_SIZE * sizeof(DESCRIPTOR) - 1, DA_LDT);

	PRIVATE void init_descriptor(DESCRIPTOR* p_desc, u32 base, u32 limit, u16 attribute)
	{
		p_desc->limit_low = limit & 0x0FFFF;
		p_desc->base_low = base & 0x0FFFF;
		p_desc->base_mid = (base >> 16) & 0x0FF;
		p_desc->attr1 = attribute & 0x0FF;
		p_desc->limit_high_attr2 = ((limit>>16) & 0x0F) | (attribute>>8) & 0xF0;
		p_desc->base_high = (base >> 24) & 0x0FF;
	}

	// 根据段名求绝对地址
	PUBLIC u32 seg2phys(u16 seg)
	{
		DESCRIPTOR* p_dest = &gdt[seg >> 3];
		return (p_dest->base_high<<24 | p_dest->base_mid<<16 | p_dest->base_low);
	}

	// vir2phys是一个宏，定义于protect.h中
	#define vir2phys(seg_base, vir) (32)((u32)(seg_base) + (u32)vir)
	\end{lstlisting}

\subsection{初始化GDT表中的TSS}
\subsubsection{定义TSS}
	TSS的定义如下：
	\begin{lstlisting}
	typedef struct s_tss
	{
		u32 backlink;
		u32 esp0;
		u32 ss0;
		u32 esp1;
		u32 ss1;
		u32 esp2;
		u32 ss2;
		u32 cr3;
		u32 eip;
		u32 flags;
		u32 eax;
		u32 ecx;
		u32 edx;
		u32 ebx;
		u32 esp;
		u32 ebp;
		u32 esi;
		u32 edi;
		u32 es;
		u32 cs;
		u32 ss;
		u32 ds;
		u32 fs;
		u32 gs;
		u32 ldt;
		u16 trap;
		u16 iobase; // I/O位图基址
	}TSS;
	\end{lstlisting}

\subsubsection{初始化TSS}
	代码如下：
	\begin{lstlisting}
	memset(&tss, 0, sizeof(tss));
	tss.ss0 = SELECTOR_KERNEL_CS;
	init_descriptor(&gdt[INDEX_TSS], vir2phys(seg2phys(SELECTOR_KERNEL_DS), &tss), sizeof(tss)-1, DA_386TSS);
	tss.iobase = sizeof(tss);
	\end{lstlisting}

\subsection{实现从ring0到ring1}
	在main.c中添加两行代码：
	\begin{lstlisting}
	// p_proc_ready是指向进程表结构的指针
	p_proc_ready = proc_table;
	restart();
	\end{lstlisting}

	restart()函数定义在kernel.asm中，如果要恢复一个进程，需要将esp指向这个结构体的开始处，然后运行一些列的pop指令将寄存器值弹出：
	\begin{lstlisting}
	restart:
		// 将esp指向进程结构体的开始处
		mov esp, [p_proc_ready]
		// 设置ldtr
		lldt [esp + P_LDT_SEL]
		// 将进程结构体的栈帧的末地址赋值给TSS中ring0堆栈指针域
		// 当ring1转移至ring0时，堆栈将被自动切换到TSS中ss0和esp0指定的位置
		// 下一次中断发生时，ss、esp、eflags、cs、eip将被依次压入进程结构体的栈帧中
		// 从ring0到ring1时候，iretd会把这些弹出
		lea eax, [esp + P_STACKTOP] 
		mov dword [tss + TSS3_S_SP0], eax

		// 中断发生时，eax、ecx、edx、ebx、esp、ebp、esi、edi、ds、es、fs和gs压栈
		// 从ring0到ring1时，需要使用pop指令弹出
		pop gs
		pop fs
		pop es
		pop ds
		popad

		// 跳过retaddr
		add esp, 4

		iretd
	\end{lstlisting}

	进程结构体中的栈帧如下图，再对照着上面的代码，应该就很好理解了：
	\sizedfic{0.3}{3.png}

\subsection{总结}
	为了实现从ring0到ring1，我们进行了以下几个步骤：
	\begin{itemize}
		\item[1.] 准备好进程体TestA()。
		\item[2.] 初始化GDT中的TSS和LDT两个描述符，以及初始化TSS。
		\item[3.] 准备进程表。
		\item[4.] 完成跳转，实现从ring0到ring1。
	\end{itemize}

\section{丰富中断处理程序}
\subsection{让时钟中断开始起作用}
	首先打开时钟中断：
	\begin{lstlisting}
	out_bype(INT_M_CTLMASK, 0xFE);
	out_bype(INT_S_CTLMASK, 0xFF);
	\end{lstlisting}

	为了告知8259A当前中断结束，我们还需要在中断处理程序中把中断结束位EOI置为1:
	\begin{lstlisting}
	hwint00:
		mov al, EOI
		out INT_M_CTL, al
		iretd
	\end{lstlisting}

	EOI和INT\_M\_CTL定义在sconst.inc中：
	\begin{lstlisting}
	INT_M_CTL equ 0x20
	INT_M_CTLMASK equ 0x21
	INT_S_CTL equ 0xA0
	INT_S_CTLMASK equ 0xA1

	EOI equ 0x20
	\end{lstlisting}

\subsection{现场的保护与恢复}
	在中断处理程序中，其实有必要进行现场的保护：
	\begin{lstlisting}
	ALIGN 16
	hwint00:
		pushad
		push ds
		push es
		push fs
		push gs

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		pop gs
		pop fs
		pop es
		pop ds
		popad

		iretd
	\end{lstlisting}

\subsection{赋值TSS中的esp0}
	时钟中断打开以后，就存在ring0和ring1之间频繁的切换。两个层级之间的切换包含：代码的跳转和堆栈的切换。\par

	当ring1切换到ring0时，我们需要用到TSS。目前为止，TSS对于我们的用处是用于保存ring0堆栈的信息，也就是ss和esp两个寄存器的信息。\par

	当进程被中断切到内核态时，各个寄存器需要被立即压栈，所以TSS中的esp0应该是当前进程的进程表中保存寄存器值的地方，也就是s\_stackframe的最高地址处。\par

	因为我们不可能在进程运行时设置esp0的值，所以需要在iretd执行之前做这件事：
	\begin{lstlisting}
	ALIGN 16
	hwint00:
		; 跳过retaddr
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		lea eax, [esp + P_STACKTOP] 
		; 给esp0赋值
		mov dword [tss + TSS3_S_SP0], eax

		pop gs
		pop fs
		pop es
		pop ds
		popad
		; 跳过retaddr
		add esp, 4

		iretd
	\end{lstlisting}

	也就是说，在切换到ring0的时候，esp0的值将赋值给esp，随后esp指向regs最高地址的，随着各寄存器值的压栈，esp指向了regs的最低地址处。
	为了下一次中断的正常进行，我们在iretd之前，将esp0设为regs的最高地址。

\subsection{内核栈}
	esp现在指向的是进程表，如果在中断处理程序中要用到堆栈操作，进程表就会被破坏掉，所以我们需要将esp指向另外的地方，也就是内核栈。

	\begin{lstlisting}
	ALIGN 16
	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		mov esp, StackTop ; 进入内核栈

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		mov esp, [p_proc_ready] ; 离开内核栈

		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4

		iretd
	\end{lstlisting}

\subsubsection{尝试比较复杂的中断例程}
	有了内核栈，我们就可以用一些比较复杂的中断处理程序：
	\begin{lstlisting}
	extern disp_str

	[SECTION .data]
	clock_int_msg db "^",0

	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		push dx, ss
		push ds, dx
		push es, dx

		mov esp, StackTop

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		push clock_int_msg
		call disp_str
		add esp, 4

		mov esp, [p_proc_ready]

		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4

		iretd
	\end{lstlisting}

\end{document}
