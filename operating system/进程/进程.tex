% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{report}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
% \renewcommand\refname{参考文献}
% \renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=C,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

\newcommand{\tablestart}{
	\interval
	\begin{longtable}{p{2cm}p{10cm}}
	\hline}
\newcommand{\tableend}{
	\hline
	\end{longtable}
	\interval}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{进程 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\chapter{进程}
\section{形成进程的必要考虑}
	CPU的个数通常总是小于进程的个数，所以我们需要进程调度，使得系统总有“正在运行的”和“正在休息的”进程。\par

	为了让“正在休息的”进程在重新醒来时记住自己挂起之前的状态，我们需要一个数据结构记录一个进程的状态。\par

	还需要考虑的是，进程和进程切换运行在不同层级上。\par

	还有一点需要考虑，就是进程自己不知道什么时候被挂起，什么时候又被启动，我们需要知道诱发进程切换的原因不只一种，比如发生了时钟中断。

\section{最简单的进程}
	首先介绍一下进程切换的情形：
	\begin{lstlisting}
	一个进程正在运行着，此时时钟中断发生。
	特权级从ring1跳到ring0，开始执行时钟中断处理程序。
	中断处理程序调用进程调度模块，指定下一个应该运行的进程。
	中断处理程序结束时，下一个进程准备就绪并开始运行，特权级从ring0跳回ring1。
	\end{lstlisting}

	从上述过程得知，我们需要完成几个部分：
	\begin{itemize}
		\item[1.] 时钟中断处理程序。
		\item[2.] 进程调度模块。
		\item[3.] 两个进程。
	\end{itemize}

\subsection{简单进程中的关键技术}
\subsubsection{进程状态的保存}
	需要考虑保存进程的状态，用于恢复进程，所以我们要把寄存器的值统统保存起来。\par
	
	一般使用push或pushad保存大多寄存器的值，并且把它写在时钟中断例程的最顶端，以便中断发生时马上被执行。\par

	当恢复进程时，使用pop来恢复寄存器的值，虽然执行指令iretd回到原先的进程。

\subsubsection{进程表PCB}
	之前已经提到过，我们需要一个数据结构记录一个进程的状态。这个数据结构叫做进程表，也就是进程控制块PCB。\par

	进程表是用来描述进程的，所以它必须独立于进程之外。每个进程有一个对应的进程表，我们会有很多个进程，所以就需要创建一个进程表数组。

\subsubsection{进程栈和内核栈}
	在进程切换时，我们需要考虑esp指向的位置。\par

	当进程运行时，esp指向进程堆栈中的某个位置。而为了把进程的寄存器状态压进进程表，esp此时又需要指向进程表的某个位置。\par

	需要知道的是，中断处理程序也可能用到堆栈操作，而显然我们不能容忍esp对进程表进行操作，所以我们应该让esp指向专门的内核栈区域。\par

	总而言之，进程切换过程中，esp将出现在3个不同的区域，如下图所示：
	\fic{1.png}

	这三个区域的描述如下：
	\begin{itemize}
		\item 进程栈，进程运行时自身的堆栈。
		\item 进程表，存储进程状态信息的数据结构。
		\item 内核栈，进程调度模块运行时使用的堆栈。
	\end{itemize}

\subsubsection{特权级变换}
	系统原先运行在ring0，所以当我们准备开始第一个进程时，我们面临一个ring0向ring1的转移。\par

	这个过程和恢复进程很相似，所以我们通过假装发生了一次时钟中断来启动第一个进程，利用iretd来实现ring0向ring1的转移。\par

	当执行时钟中断处理程序时，需要从ring1向ring0转移，此时要从当前TSS中取出内层ss和esp作为目标代码的ss和esp，所以我们必须事先准备好TSS。\par

	因为每个进程相对独立，所以这些任务状态段相互独立。我们需要把涉及到的描述符放在局部描述符表LDT中，这意味着我们还需要为每个进程准备LDT。

\section{从ring0到ring1}
\subsection{时钟中断处理程序}
	如果想实现从ring0到ring1的转移，只需要用一个iretd指令。\par

	我们的时钟中断处理程序如下：
	\begin{lstlisting}
	ALIGN 16
	hwint00:
		iretd
	\end{lstlisting}

\subsection{进程表、进程体、GDT、TSS}
	一个进程开始之前，我们必须初始化cs、ds、es、fs、gs、ss、esp、eip、eflags，才能让一个进程正常运行。\par

	其中，cs、ds、fs、es这些段寄存器对应的是LDT中的描述符，所以我们还要初始化局部描述符表。
	因为LDT本身是进程的一部分，所以需要把它放在进程表中，并且还需要在GDT中增加相应的描述符，对应的选择子将被加载给ldtr。\par

	因为每个进程都有一个任务状态段，所以我们必须初始化一个TSS，并且在GDT中增加相应的描述符，对应的选择子将被加载给tr。
	目前，TSS中我们只会用到ss和esp，所以我们只初始化它们两个。\par

	gs指向显存的描述符，用于访问显存。\par

	根据上述描述，各寄存器和GDT、LDT、TSS的关系如下图：
	\fic{2.png}
	
\subsection{一个简单的进程执行体}
	我们的第一个进程执行体如下：
	\begin{lstlisting}
	// 位于main.c文件
	void TestA()
	{
		int i = 0;
		while(1)
		{
			disp_str("A");
			disp_int(i++);
			disp_str(".");
			delay(1);
		}
	}

	// delay()函数放置在klib.c文件中
	PUBLIC void delay(int time)
	{
		int i, j, k;
		for(k = 0; k < time; k++)
		{
			for(i = 0; i < 10; i++)
			{
				for(j = 0; j < 10000; j++){}
			}
		}
	}
	\end{lstlisting}

	这里，我们为了等待中断的发生，我们将在重新放置堆栈和GDT表之后，将跳转到一个kernel\_main()函数：
	\begin{lstlisting}
	// 位于main.c文件
	PUBLIC int kernel_main()
	{
		disp_str("----\"kernel_main\" begins----\n");
		while(1){}
	}

	// 修改kernel.asm文件
	extern kernel_main
		...
		jmp kernel_main
	\end{lstlisting}

\subsection{定义进程表}
	进程表就是存储进程状态信息的数据结构，在这之前我们还要定义栈帧和进程结构体。

\subsubsection{定义栈帧}
	\begin{lstlisting}
	// 位于proc.h文件
	typedef struct s_stackframe
	{
		// gs、fs、es、ds、edi、esi、ebp、kernel_esp、ebx、edx、ecx、eax将被save()函数压栈
		u32 gs;
		u32 fs;
		u32 es;
		u32 ds;
		u32 edi;
		u32 esi;
		u32 ebp;
		u32 kernel_esp;
		u32 ebx;
		u32 edx;
		u32 ecx;
		u32 eax;

		u32 retaddr; // 暂时不知道它有什么用

		// 在中断发生时将被CPU压栈
		u32 eip;
		u32 cs;
		u32 eflags;
		u32 esp;
		u32 ss;
	}STACK_FRAME;
	\end{lstlisting}

\subsubsection{定义进程结构体}
	根据之前的总结，我们知道，一个进程，拥有进程表、LDT、指向LDT的选择子、进程号和进程名。所以它的代码定义如下：
	\begin{lstlisting}
	// 位于proc.h文件
	typedef struct s_proc
	{
		STACK_FRAME regs;
		u16 ldt_sel;
		DESCRIPTOR ldts[LDT_SIZE];
		u32 pid;
		char p_name[16];
	}PROCESS;
	\end{lstlisting}

\subsubsection{初始化进程表}
	进程表就是进程结构体的数组：
	\begin{lstlisting}
	// 位于global.c文件
	PUBLIC PROCESS proc_table[NR_TASKS];
	\end{lstlisting}

	初始化进程表的代码如下：
	\begin{lstlisting}
	PROCESS* p_proc = proc_table;

	// 初始化ldt_sel
	p_proc->ldt_sel = SELECTOR_LDT_FIRST;

	// 初始化ldts[LDT_SIZE]
	memcpy(&p_proc->ldts[0], &gdt[SELECTOR_KERNEL_CS>>3], sizeof(DESCRIPTOR));
	p_proc->ldts[0].attr1 = DA_C | PRIVILEGE_TASK << 5;
	memcpy(&p_proc->ldts[1], &gdt[SELECTOR_KERNEL_DS>>3], sizeof(DESCRIPTOR));
	p_proc->ldts[1].attr1 = DA_DRW | PRIVILEGE_TASK << 5;

	// 初始化栈帧regs中的寄存器
	// cs指向LDT中第一个描述符
	p_proc->regs.cs = (0 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	// ds、es、fs、ss指向LDT中的第二个描述符
	p_proc->regs.ds = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	p_proc->regs.es = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	p_proc->regs.fs = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	p_proc->regs.ss = (8 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
	// gs指向显存
	p_proc->regs.gs = (SELECTOR_KERNEL_GS & SA_RPL_MASK) | RPL_TASK;
	// eip指向TestA，进程将从TestA的入口地址开始运行
	p_proc->regs.eip = (u32)TestA;
	// esp指向了单独的栈
	p_proc->regs.esp = (u32)task_stack + TASK_SIZE_TOTAL;
	// 将IOPL位设为1，让进程可以使用I/O指令
	p_proc->regs.eflags = 0x1202;
	\end{lstlisting}

	上述代码中的宏定义于protect.h中：
	\begin{lstlisting}
	#define INDEX_DUMMY 0
	#define INDEX_FLAT_C 1
	#define INDEX_FLAT_RW 2
	#define INDEX_VIDEO 3
	#define INDEX_TSS 4
	#define INDEX_LDT_FIRST 5

	#define SELECTOR_DUMMY 0
	#define SELECTOR_FLAT_C 0x08
	#define SELECTOR_FLAT_RW 0x10
	#define SELECTOR_VIDEO (0x18 + 3)
	#define SELECTOR_TSS 0x20
	#define SELECTOR_LDT_FIRST 0x28

	#define SELECTOR_KERNEL_CS SELECTOR_FLAT_C
	#define SELECTOR_KERNEL_DS SELECTOR_FLAT_RW
	#define SELECTOR_KERNEL_GS SELECTOR_VIDEO

	// 每个任务有一个单独的LDT
	#define LDT_SIZE 2

	#define SA_RPL_MASK 0xFFFC
	#define SA_RPL0 0
	#define SA_RPL1 1
	#define SA_RPL2 2
	#define SA_RPL3 3

	#define SA_TI_MASK 0xFFFB
	#define SA_TIG 0
	#define SA_TIL 4
	\end{lstlisting}

\subsection{初始化GDT表中的LDT描述符}
	进程拥有LDT表，而GDT中需要有进程的LDT的描述符，所有我们还需要初始化GDT中进程LDT的描述符：
	\begin{lstlisting}
	// 位于proctect.h
	init_descriptor(&gdt[INDEX_LDT_FIRST], vir2phys(seg2phys(SELECTOR_KERNEL_DS), proc_table[0].ldts), LDT_SIZE * sizeof(DESCRIPTOR) - 1, DA_LDT);

	PRIVATE void init_descriptor(DESCRIPTOR* p_desc, u32 base, u32 limit, u16 attribute)
	{
		p_desc->limit_low = limit & 0x0FFFF;
		p_desc->base_low = base & 0x0FFFF;
		p_desc->base_mid = (base >> 16) & 0x0FF;
		p_desc->attr1 = attribute & 0x0FF;
		p_desc->limit_high_attr2 = ((limit>>16) & 0x0F) | (attribute>>8) & 0xF0;
		p_desc->base_high = (base >> 24) & 0x0FF;
	}

	// 根据段名求绝对地址
	PUBLIC u32 seg2phys(u16 seg)
	{
		DESCRIPTOR* p_dest = &gdt[seg >> 3];
		return (p_dest->base_high<<24 | p_dest->base_mid<<16 | p_dest->base_low);
	}

	// vir2phys是一个宏，定义于protect.h中
	#define vir2phys(seg_base, vir) (32)((u32)(seg_base) + (u32)vir)
	\end{lstlisting}

\subsection{初始化GDT表中的TSS}
\subsubsection{定义TSS}
	TSS的定义如下：
	\begin{lstlisting}
	typedef struct s_tss
	{
		u32 backlink;
		u32 esp0;
		u32 ss0;
		u32 esp1;
		u32 ss1;
		u32 esp2;
		u32 ss2;
		u32 cr3;
		u32 eip;
		u32 flags;
		u32 eax;
		u32 ecx;
		u32 edx;
		u32 ebx;
		u32 esp;
		u32 ebp;
		u32 esi;
		u32 edi;
		u32 es;
		u32 cs;
		u32 ss;
		u32 ds;
		u32 fs;
		u32 gs;
		u32 ldt;
		u16 trap;
		u16 iobase; // I/O位图基址
	}TSS;
	\end{lstlisting}

\subsubsection{初始化TSS}
	代码如下：
	\begin{lstlisting}
	memset(&tss, 0, sizeof(tss));
	tss.ss0 = SELECTOR_KERNEL_CS;
	init_descriptor(&gdt[INDEX_TSS], vir2phys(seg2phys(SELECTOR_KERNEL_DS), &tss), sizeof(tss)-1, DA_386TSS);
	tss.iobase = sizeof(tss);
	\end{lstlisting}

\subsection{实现从ring0到ring1}
	在main.c中添加两行代码：
	\begin{lstlisting}
	// p_proc_ready是指向进程表结构的指针
	p_proc_ready = proc_table;
	restart();
	\end{lstlisting}

	restart()函数定义在kernel.asm中，如果要恢复一个进程，需要将esp指向这个结构体的开始处，然后运行一些列的pop指令将寄存器值弹出：
	\begin{lstlisting}
	restart:
		// 将esp指向进程结构体的开始处
		mov esp, [p_proc_ready]
		// 设置ldtr
		lldt [esp + P_LDT_SEL]
		// 将进程结构体的栈帧的末地址赋值给TSS中ring0堆栈指针域
		// 当ring1转移至ring0时，堆栈将被自动切换到TSS中ss0和esp0指定的位置
		// 下一次中断发生时，ss、esp、eflags、cs、eip将被依次压入进程结构体的栈帧中
		// 从ring0到ring1时候，iretd会把这些弹出
		lea eax, [esp + P_STACKTOP] 
		mov dword [tss + TSS3_S_SP0], eax

		// 中断发生时，eax、ecx、edx、ebx、esp、ebp、esi、edi、ds、es、fs和gs压栈
		// 从ring0到ring1时，需要使用pop指令弹出
		pop gs
		pop fs
		pop es
		pop ds
		popad

		// 跳过retaddr
		add esp, 4

		iretd
	\end{lstlisting}

	进程结构体中的栈帧如下图，再对照着上面的代码，应该就很好理解了：
	\sizedfic{0.3}{3.png}

\subsection{总结}
	为了实现从ring0到ring1，我们进行了以下几个步骤：
	\begin{itemize}
		\item[1.] 准备好进程体TestA()。
		\item[2.] 初始化GDT中的TSS和LDT两个描述符，以及初始化TSS。
		\item[3.] 准备进程表。
		\item[4.] 完成跳转，实现从ring0到ring1。
	\end{itemize}

\section{丰富中断处理程序}
\subsection{让时钟中断开始起作用}
	首先打开时钟中断：
	\begin{lstlisting}
	out_bype(INT_M_CTLMASK, 0xFE);
	out_bype(INT_S_CTLMASK, 0xFF);
	\end{lstlisting}

	为了告知8259A当前中断结束，我们还需要在中断处理程序中把中断结束位EOI置为1:
	\begin{lstlisting}
	hwint00:
		mov al, EOI
		out INT_M_CTL, al
		iretd
	\end{lstlisting}

	EOI和INT\_M\_CTL定义在sconst.inc中：
	\begin{lstlisting}
	INT_M_CTL equ 0x20
	INT_M_CTLMASK equ 0x21
	INT_S_CTL equ 0xA0
	INT_S_CTLMASK equ 0xA1

	EOI equ 0x20
	\end{lstlisting}

\subsection{现场的保护与恢复}
	在中断处理程序中，其实有必要进行现场的保护：
	\begin{lstlisting}
	ALIGN 16
	hwint00:
		pushad
		push ds
		push es
		push fs
		push gs

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		pop gs
		pop fs
		pop es
		pop ds
		popad

		iretd
	\end{lstlisting}

\subsection{赋值TSS中的esp0}
	时钟中断打开以后，就存在ring0和ring1之间频繁的切换。两个层级之间的切换包含：代码的跳转和堆栈的切换。\par

	当ring1切换到ring0时，我们需要用到TSS。目前为止，TSS对于我们的用处是用于保存ring0堆栈的信息，也就是ss和esp两个寄存器的信息。\par

	当进程被中断切到内核态时，各个寄存器需要被立即压栈，所以TSS中的esp0应该是当前进程的进程表中保存寄存器值的地方，也就是s\_stackframe的最高地址处。\par

	因为我们不可能在进程运行时设置esp0的值，所以需要在iretd执行之前做这件事：
	\begin{lstlisting}
	ALIGN 16
	hwint00:
		; 跳过retaddr
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		lea eax, [esp + P_STACKTOP] 
		; 给esp0赋值
		mov dword [tss + TSS3_S_SP0], eax

		pop gs
		pop fs
		pop es
		pop ds
		popad
		; 跳过retaddr
		add esp, 4

		iretd
	\end{lstlisting}

	也就是说，在切换到ring0的时候，esp0的值将赋值给esp，随后esp指向regs最高地址的，随着各寄存器值的压栈，esp指向了regs的最低地址处。
	为了下一次中断的正常进行，我们在iretd之前，将esp0设为regs的最高地址。

\subsection{内核栈}
	esp现在指向的是进程表，如果在中断处理程序中要用到堆栈操作，进程表就会被破坏掉，所以我们需要将esp指向另外的地方，也就是内核栈。

	\begin{lstlisting}
	ALIGN 16
	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		mov esp, StackTop ; 进入内核栈

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		mov esp, [p_proc_ready] ; 离开内核栈

		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4

		iretd
	\end{lstlisting}

\subsubsection{尝试比较复杂的中断例程}
	有了内核栈，我们就可以用一些比较复杂的中断处理程序：
	\begin{lstlisting}
	extern disp_str

	[SECTION .data]
	clock_int_msg db "^",0

	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		push dx, ss
		push ds, dx
		push es, dx

		mov esp, StackTop

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		push clock_int_msg
		call disp_str
		add esp, 4

		mov esp, [p_proc_ready]

		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4

		iretd
	\end{lstlisting}

\subsubsection{中断重入}
	我们现在想要在中断处理过程中允许下一个中断发生，先来感受一下中断重入的现象：
	\begin{lstlisting}
	extern delay

	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		mov esp, StackTop
		
		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al
	
		sti ; 发生时钟中断时会把中断关掉，为了体会中断重入的现象，我们在此把中断打开

		push clock_int_msg
		call disp_int
		add esp, 4

		push 1
		call delay
		add esp, 4

		cli

		mov esp, [p_proc_ready]

		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4

		iretd
	\end{lstlisting}

	为了让中断不会不断地重入，我们需要让中断处理程序知道自己是不是在嵌套执行，此时我们只需要设置一个全局变量。
	这个全局变量有一个初值-1，当中断处理程序开始执行时它自加，结束时自减。\par

	在处理程序开头处这个变量需要被检查一下，如果值不是0，则说明在一次中断未处理完之前就又发生了一次中断，这时直接跳到最后。
	代码如下：
	\begin{lstlisting}
	// 设置全局变量
	PUBLIC int kernel_main()
	{
		k_reenter = -1;
	}

	; 在中断例程中加入k_reenter自加以及判断是否为0的代码
	extern k_reenter

	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		inc dword [k_reenter] ; k_reenter自加
		cmp dword [k_reenter], 0
		jne .re_enter

		mov esp, StackTop

		sti

		push clock_int_msg
		call disp_str
		add esp, 4

		cli

		mov esp, [p_proc_ready]

		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

	.re_enter:
		dec dword [k_reenter]
		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4

		iretd
	\end{lstlisting}

\section{多进程}
\subsection{添加一个进程体}
	进程体B的内容如下：
	\begin{lstlisting}
	void TestB()
	{
		int i = 0x1000;
		while(1)
		{
			disp_str("B");
			disp_int(i++);
			disp_str(".");
			delay(1);
		}
	}
	\end{lstlisting}

\subsection{相关的变量和宏}
	进程有四个要素：进程体、进程表、GDT和TSS。接下来我们来初始化进程表。\par

	为了让我们的代码实现自动化，让增加一个进程变得简单而迅速，我们使用一个task\_table数组。
	这个数组的每一项定义好一个任务的开始地址、堆栈，在初始化进程表示，只要用一个for循环依次读取每一项，然后填充到相应的进程表项中就可以了。\par

	首先在proc.h中声明一个数组类型：
	\begin{lstlisting}
	typedef void (*task_f)();

	typedef struct s_task
	{
		task_f initial_eip;
		int stacksize;
		char name[32];
	}
	\end{lstlisting}

	随后我们在global.c中增加task\_table中增加一个定义：
	\begin{lstlisting}
	PUBLIC TASK task_table[NR_TASKS] = {{TestA, STACK_SIZE_TESTA, "TestA"}, {TestB, STACK_SIZE_TESTB, "TestB"}};
	\end{lstlisting}

	一些相关的宏的定义如下：
	\begin{lstlisting}
	#define NR_TASKS 2

	#define STACK_SIZE_TESTA 0x8000
	#define STACK_SIZE_TESTB 0x8000

	#define STACK_SIZE_TOTAL (STACK_SIZE_TESTA + \
							  STACK_SIZE_TESTB)
	\end{lstlisting}

\subsection{初始化进程表}
	下面用for循环和task\_table数组进行进程表的初始化工作：
	\begin{lstlisting}
	PUBLIC int kernel_main()
	{
		disp_str("----\"kernel_main\" begins----");

		TASK* p_task = task_table;
		PROCESS* p_proc = proc_table;
		char* p_task_stack = task_stack + STACK_SIZE_TOTAL;
		u16 selector_ldt = SELECTOR_LDT_FIRST;
		int i;

		for(i = 0; i < NR_TASKS; i++)
		{
			strcpy(p_proc->p_name; p_task->name);
			p_proc->pid = i;
			p_proc->ldt_sel = selector_ldt;
			memcpy(&p_proc->ldts[0], &gdt[SELECTOR_KERNEL_CS >> 3], sizeof[DESCRIPTOR]);
			p_proc->ldts[0].attr1 = DA_C | PRIVILEGE_TASK << 5;
			memcpy(&p_proc->ldts[1], &gdt[SELECTOR_KERNEL_DS >> 3], sizeof[DESCRIPTOR]);
			p_proc->ldts[1].attr1 = DA_DRW | PRIVILEGE_TASK << 5;
			p_proc->regs.cs = ((8*0) & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
			p_proc->regs.ds = ((8*1) & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
			p_proc->regs.es = ((8*1) & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
			p_proc->regs.fs = ((8*1) & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
			p_proc->regs.ss = ((8*1) & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | RPL_TASK;
			p_proc->regs.gs = (SELECTOR_KERNEL_GS & SA_RPL_MASK) | RPL_TASK;

			p_proc->regs.eip = (u32)p_task->initial_eip;
			p_proc->regs.esp = (u32)p_task_stack;
			p_proc->regs.eflags = 0x1202;

			p_task_stack -= p_task->stacksize;
			p_proc++;
			p_task++;
			selector_ldt += 1 << 3;
		}

		k_reenter = -1;

		p_proc_ready = proc_table;
		restart();

		while(1){}
	}
	\end{lstlisting}

\subsection{初始化LDT}
	 每一个进程都会在GDT中对应有一个LDT描述符，我们刚刚在进程表中初始化了LDT描述符对应的选择子，但是还没初始化描述符本身。\par

	 下面使用循环初始化进程的描述符：
	 \begin{lstlisting}
	 int i;
	 PROCESS* p_proc = proc_table;
	 u16 selector_ldt = INDEX_LDT_FIRST << 3;
	 for(i = 0; i < NR_TASKS; i++)
	 {
		 init_descriptor(&gdt[selector_ldt>>3], vir2phys(seg2phys(SELECTOR_KERNEL_DS), proc_table[i].ldts), LDT_SIZE*sizeof(DESCRIPTOR)-1, DA_LDT);
		 p_proc++;
		 selector_ldt += 1 << 3;
	 }
	 \end{lstlisting}

\subsection{修改中断处理程序}
	一个进程由“睡眠”状态变成“运行”状态，需要将esp指向进程表项的开始处，然后在执行lldt之后经历一系列pop指令恢复各个寄存器的值。
	因为进程的一切信息都包含在进程表中，所以，想要恢复不同的进程，只需要将esp指向不同的进程表就可以了。\par

	代码如下：
	\begin{lstlisting}
	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push bfseries
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		inc dword [k_reenter]
		cmp dword [k_reenter], 0
		jne .re_enter

		mov esp, StackTop

		sti
		push 0
		call clock_handler
		add esp, 4
		cli

		mov esp, [p_proc_ready]
		lldt [esp + P_LDT_SEL]
		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

	.re_enter:
		dec dword [k_reenter]
		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4
		iretd
	\end{lstlisting}

	时钟中断的核心代码clock\_handler函数如下：
	\begin{lstlisting}
	PUBLIC void clock_handler(int irq)
	{
		disp_str("#");
		p_proc_ready++;
		if(p_proc_ready >= proc_table + NR_TASKS)
			p_proc_ready = proc_table;
	}
	\end{lstlisting}

\subsection{添加一个任务的步骤总结}
	步骤如下：
	\begin{itemize}
		\item[1.] 首先添加一个进程体：
		\begin{lstlisting}
	void TestC()
	{
		int i = 0x2000;
		while(1)
		{
			disp_str("C");
			disp_int(i++);
			disp_str(".");
			delay(1);
		}
	}
		\end{lstlisting}

		\item[2.] 然后在task\_table中添加一项进程：
		\begin{lstlisting}
	PUBLIC TASK task_table[NR_TASKS] = {
		{TestA, STACK_SIZE_TESTA, "TestA"},
		{TestB, STACK_SIZE_TESTB, "TestB"},
		{TestC, STACK_SIZE_TESTC, "TestC"}
	};	
		\end{lstlisting}

		\item[3.] 最后需要添加一些宏变量：
		\begin{lstlisting}
	#define NR_TASKS 3

	#define STACK_SIZE_TESTA 0x8000
	#define STACK_SIZE_TESTB 0x8000
	#define STACK_SIZE_TESTC 0x8000

	#define STACK_SIZE_TOTAL (STACK_SIZE_TESTA + \
							  STACK_SIZE_TESTB + \
							  STACK_SIZE_TESTC)
		\end{lstlisting}
	\end{itemize}

\section{Minix的中断处理}
	Minix的中断处理代码充满了美感，下面是它的中断处理机制的代码的一部分：
	\begin{lstlisting}
	#define hwint_master(irq)	\
		call save				\
		inb INT_CTLMSK 			\
		orb al, (1<<irq)		\
		outb INT_CTLMSK			\
		movb al, ENABLE			\
		outb INT_CTL			\
		sti						\
		push irq				\
		call (_irq_table + 4*irq) \
		pop ecx 				\
		cli 					\
		test eax, eax			\
		jz 0f					\
		inb INT_CTLMSK			\
		andb al, -[1<<irq]		\
		outb INT_CTLMSK			\
	0:	ret

		.align 16
	_hwint00:
		hwint_master(0)

		.align 16
	_hwint01:
		hwint_master(1)

		.align 16
	_hwint02:
		hwint_master(2)

		.align 16
	_hwint03:
		hwint_master(3)

		.align 16
	_hwint04:
		hwint_master(4)

		.align 16
	_hwint05:
		hwint_master(5)

		.align 16
	_hwint06:
		hwint_master(6)

		.align 16
	_hwint07:
		hwint_master(7)

	#define hwint_slave(irq)	\
		call save				\
		inb INT2_CTLMASK		\
		orb al, (1<<[irq-8])	\
		outb INT2_CTLMASK		\
		movb al, ENABLE			\
		outb INT_CTL			\
		jmp .+2					\
		outb INT2_CTL			\
		sti						\
		push irq				\
		call (_irq_table + 4*irq) \
		pop ecx					\
		cli						\
		test eax, eax			\
		jz 0f					\
		inb INT2_CTLMASK		\
		andb al, -[1<<[irq-8]]	\
		outb INT2_CTLMASK		\
	0:	ret
		
		.align 16
	_hwint08:
		hwint_slave(8)

		.align 16
	_hwint09:
		hwint_slave(9)

		.align 16
	_hwint10:
		hwint_slave(10)

		.align 16
	_hwint11:
		hwint_slave(11)

		.align 16
	_hwint12:
		hwint_slave(12)

		.align 16
	_hwint13:
		hwint_slave(13)

		.align 16
	_hwint14:
		hwint_slave(14)

		.align 16
	_hwint15:
		hwint_slave(15)
	\end{lstlisting}

	hwint\_master首先调用一个函数save，将寄存器的值保存起来，然后操纵8259A避免在处理当前中断的同时发生同样类型的中断。
	随后，给8259A的中断命令寄存器发出中断结束命令EOI。然后用sti指令打开种顿啊，
	调用函数(*\_irq\_table[irq])(irq)，这是与当前中断相关的一个例程。
	再用cli关中断、test指令判断函数(*\_irq\_table[irq])(irq)的返回值，如果非零的话就重新打开当前发生的中断，如果是零的话就直接ret。\par

	首先来看看save函数：
	\begin{lstlisting}
	.align 16
save:
	cld
	pushad
o16 push ds
o16	push es
o16	push fs
o16	push gs
	mov dx, ss
	mov ds, dx
	mov es, dx
	mov eax, esp
	incb (_k_reenter)
	jnz set_restart1
	mov esp, k_stktop
	push _restart
	xor ebp, ebp
	jmp RETADR-P_STACKBASE(eax)

	.align 4
set_restart1:
	push restart1
	jmp RETADR-P_STACKBASE(eax)
	\end{lstlisting}

	上面函数中的代码大部分挺熟悉的，主要是jmp RETADR-P\_STACKBASE(eax)需要理解。这里的eax指向进程表的初始地址，而RETADR-P\_STACKBASE的定义如下：
	\begin{lstlisting}
	P_STACKBASE = 0
	GSREG = P_STACKBASE
	FSREG = GSREG + 2
	ESREG = FSREG + 2
	DSREG = ESREG + 2
	DIREG = DSREG + 2
	SIREG = DIREG + w
	BPREG = SIREG + w
	STREG = SIREG + w
	BXREG = STREG + w
	DXREG = BXREG + w
	CXREG = DXREG + w
	AXREG = CXREG + w
	RETADR = AXREG + w
	PCREG = RETADR + w
	CSREG = PCREG + w
	PSWREG = CSREG + w
	SPREG = PSWREG + w
	SSREG = SPREG + w
	P_STACKTOP = SSREG + w
	P_LDT_SEL = P_STACKTOP
	P_LDT = P_LDT_SEL + w
	\end{lstlisting}

	所以RETADR-P\_STACKBASE的值就是执行call save这条指令时压栈的返回地址相对于进程表起始地址的偏移。
	所以jmp RETADR-P\_STACKBASE(eax)将跳转到inb INT\_CTLMASK以后继续向下执行。\par

	save函数还设置了，如果非中断重入，就跳转到\_restart，如果中断重入，就跳转到restart1，这两个函数的代码如下：
	\begin{lstlisting}
	_restart:
		cmp (_held_head), 0
		jz over_call_unhold
		call _unhold
	over_call_unhold:
		mov esp, (_proc_ptr)
		lldt P_LDT_SEL(esp)
		lea eax, P_STACKTOP(esp)
		mov (_ess+TSS3_S_SP0), eax
	restart1:
		decb (_k_reenter)
	o16 pop gs
	o16 pop fs
	o16 pop es
	o16 pop ds
		popad
		add esp, 4
		iretd
	\end{lstlisting}

\subsection{对minix代码的学习}
	首先学习对中断重入方式的处理：
	\begin{lstlisting}
	hwint00:
		sub esp, 4
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		inc byte [gs:0]

		mov al, EOI
		out INT_M_CTL, al

		inc dword [k_reenter]
		cmp dword [k_reenter], 0
		jne .1

		mov esp, StackTop

		push restart
		jmp .2

	.1:
		push restart_reenter

	.2:
		sti

		push 0
		call clock_handler
		add esp, 4

		cli

		ret

	
	; 从hwint00中分离出restart代码
	restart:
		mov esp, [p_proc_ready]
		lldt [esp + P_LDT_SEL]
		lea eax, [esp + P_STACKTOP]
		mov dword [tss + TSS3_S_SP0], eax

	restart_reenter:
		dec dword [k_reenter]
		pop gs
		pop fs
		pop es
		pop ds
		popad
		add esp, 4

		iretd
	\end{lstlisting}

	这里的中断重入处理方式，不管是否重入，都会调用clock\_handler函数，所以我们还需要修改时钟中断处理程序，使得它发生中断重入时直接返回：
	\begin{lstlisting}
	PUBLIC void clock_handler(int irq)
	{
		disp_str("#");

		if(k_reenter != 0)
		{
			disp_str("!");
			return;
		}

		p_proc_ready++;
		if(p_proc_ready >= proc_table + NR_TASKS)
			p_proc_ready = proc_table;
	}
	\end{lstlisting}

	随后分离出save函数的代码：
	\begin{lstlisting}
	hwint00:
		call save

		mov al, EOI
		out INT_M_CTL, al

		sti
		push 0
		call clock_handler
		add esp, 4
		cli

		ret

	save:
		pushad
		push ds
		push es
		push fs
		push gs
		mov dx, ss
		mov ds, dx
		mov es, dx

		mov eax, esp

		inc dword [k_reenter]
		cmp dword [k_reenter], 0
		jne .1
		mov esp, StackTop
		push restart
		jmp [eax + RETADR - P_STACKBASE]
	
	.1:
		push restart_reenter
		jmp [eax + RETADR - P_STACKBASE]
	\end{lstlisting}

	我们之前是允许时钟中断时再次发生时钟中断的，现在我们来禁止这种现象：
	\begin{lstlisting}
	hwint00:
		call save

		; 禁止时钟中断发生
		in al, INT_M_CTLMASK
		or al, 1
		out INT_M_CTLMASK, al

		mov al, EOI
		out INT_M_CTL, al

		sti
		push 0
		call clock_handler
		add esp, 4
		cli

		; 允许时钟中断发生
		in al, INT_M_CTLMASK
		and al, 0xFE
		out INT_M_CTLMASK, al

		ret
	\end{lstlisting}

	将时钟中断处理程序改成一个类似的宏，用于通用的中断处理程序中:
	\begin{lstlisting}
	extern irq_table

	%macro hwint_master 1
		call save
		in al, INT_M_CTLMASK
		or al, (1 << %1)
		out INT_M_CTLMASK, al

		mov al, EOI
		out INT_M_CTL, al

		sti
		push %1
		call [irq_table + 4 * %1]
		pop ecx
		cli

		in al, INT_M_CTLMASK
		and al, -(1 << %1)
		out INT_M_CTLMASK, al
		ret
	%endmacro
	\end{lstlisting}

	irq\_table是一个函数指针数组，存放着中断处理程序，需要初始化irq\_table:
	\begin{lstlisting}
	PUBLIC void init_8259A()
	{
		int i;
		for(i = 0; i < NR_IRQ; i++)
			irq_table[i] = spurious_irq;
	}
	\end{lstlisting}

	我们再写一个函数put\_irq\_handler来为irq\_table赋值：
	\begin{lstlisting}
	PUBLIC void put_irq_handler(int irq, irq_handler handler)
	{
		disable_irq(irq);
		irq_table[irq] = handler;
	}
	\end{lstlisting}

	然后在kernel\_main()函数中指定时钟中断处理程序：
	\begin{lstlisting}
	PUBLIC int kernel_main()
	{
		put_irq_handler(CLOCK_IRQ, clock_handler);
		enable_irq(CLOCK_IRQ);
	}
	\end{lstlisting}

	这里用到的disable\_irq函数和enable\_irq函数如下：
	\begin{lstlisting}
	global enable_irq
	global disable_irq

	disable_irq:
		mov ecx, [esp + 4]
		pushf
		cli
		mov ah, 1
		rol ah, cl
		cmp cl, 8
		jae disable_8

	disable_0:
		in al, INT_M_CTLMASK
		test al, ah
		jnz dis_already
		or al, ah
		out INT_M_CTLMASK, al
		popf
		mov eax, 1
		ret

	disable_8:
		in al, INT_S_CTLMASK
		test al, ah
		jnz dis_already
		or al, ah
		out INT_S_CTLMASK, al
		popf
		mov eax, 1
		ret

	dis_already:
		popf
		xor eax, eax
		ret

	enable_irq:
		mov ecx, [esp + 4]
		pushf
		cli
		mov ah, -1
		rol ah, cl
		cmp cl, 8
		jae enable_8
	enable_0:
		in al, INT_M_CTLMASK
		and al, ah
		out INT_M_CTLMASK, al
		popf
		ret
	enable_8:
		in al, INT_S_CTLMASK
		and al, ah
		out INT_S_CTLMASK, al
		popf
		ret
	\end{lstlisting}

\subsection{实现进程需要的步骤}
	步骤如下：
	\begin{itemize}
		\item[1.] 初始化8259A。
		\item[2.] 初始化IDT。
		\item[3.] 初始化GDT中的TSS和LDT两个描述符，以及初始化TSS。
		\item[4.] 初始化进程表。
		\item[5.] 指定时钟中断处理程序。
		\item[6.] 让8259A可以接收时钟中断。
		\item[7.] restart()。
	\end{itemize}

\end{document}
