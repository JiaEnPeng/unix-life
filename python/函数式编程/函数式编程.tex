% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=python,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{函数式编程 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{函数式编程}
	函数式编程是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量。
	对于函数式编程的函数，只要输入是确定的，输出就是确定的。\par

	函数式编程的另一个特点是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

\subsection{高阶函数}
	对于python而言，变量可以指向函数，而函数名也可以作为一个变量。
	如果一个函数可以接收另一个函数作为参数，那么这种函数就称之为高阶函数。

\subsubsection{变量可以指向函数}
	在python中，函数本身可以赋值给变量，也就是说，变量可以指向函数。如下例所示：
	\begin{lstlisting}
	# abs()是python内置的求绝对值的函数
	f = abs
	f(-10)
	# 输出结果为10
	# 变量f指向abs函数本身
	\end{lstlisting}

\subsubsection{函数名也是变量}
	在python中，函数名就是指向函数的变量，所以也可以把函数名当作变量。如下例所示：
	\begin{lstlisting}
	# abs()是python内置的求绝对值的函数
	abs = 10
	# abs现在指向10，无法再通过abs(-10)调用求绝对值函数
	\end{lstlisting}

\subsubsection{传入函数}
	对于高阶函数，它可以接收另一个函数作为参数。如下例所示：
	\begin{lstlisting}
	def add(x, y, f):
		return f(x) + f(y)

	add(-5, 6, abs)
	# 输出结果为11
	\end{lstlisting}

\subsubsection{map函数}
	map()函数接收两个参数，一个是函数，另一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。
	如下例所示：
	\begin{lstlisting}
	def f(x):
		return x * x

	map(f, [1, 2, 3])
	# 返回[1, 4, 9]
	\end{lstlisting}

\subsubsection{reduce函数}
	reduce()函数接收两个参数，一个是函数，另一个是序列，reduce将一个函数作用在一个序列上。
	这个函数必须接受两个参数，然后reduce将结果和序列的下一个元素传入函数，依次进行计算。
	reduce函数的效果如下所示：
	\begin{lstlisting}
	reduce(f, [x1, x2, x3]) = f(f(x1, x2), x3)
	\end{lstlisting}

	reduce的使用如下例所示：
	\begin{lstlisting}
	def add(x, y):
		return x + y

	reduce(add, [1, 3, 5, 7, 9])
	# 输出结果为25
	\end{lstlisting}

\subsubsection{filter函数}
	filter()函数接收两个参数，一个是函数，另一个是序列。
	filter()把传入的函数依次作用到序列的每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
	如下例所示：
	\begin{lstlisting}
	def is_odd(n):
		return n % 2 == 1

	filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])
	# 返回[1, 5, 9, 15]
	\end{lstlisting}

\subsubsection{sorted函数}
	sorted()函数接收两个参数，一个是序列，另一个是函数，它通过这个函数来实现自定义的排序。
	如下例所示：
	\begin{lstlisting}
	def reversed_cmp(x, y):
		if x > y:
			return -1
		else:
			return 1
		return 0

	sorted([36, 5, 12, 9, 21], reversed_cmp)
	# 返回[36, 21, 12, 9, 5]
	\end{lstlisting}

\subsubsection{将函数作为返回值}
	高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
	如下例所示：
	\begin{lstlisting}
	def lazy_sum(*args):
		def sum():
			ax = 0
			for n in args:
				ax = ax + n
			return ax
		return sum

	f = lazy_sum(1, 3, 5, 7, 9)
	# f现在指向sum()函数
	f()
	# 输出结果为25
	\end{lstlisting}

	需要注意的是，每次调用都会返回一个新的函数，这些函数的地址值不同，如下所示：
	\begin{lstlisting}
	f1 = lazy_sum(1, 3, 5, 7, 9)
	f2 = lazy_sum(1, 3, 5, 7, 9)
	f1 == f2
	# 输出结果为False
	\end{lstlisting}

	还有一点需要注意的是，返回函数中的变量如果后续发生了变化，返回函数的输出结果也会发生改变，如下例所示：
	\begin{lstlisting}
	def count():
		fs = []
		for i in range(1, 4):
			def f():
				return i * i
			fs.append(f)
		return fs

	f1, f2, f3 = count()
	# f1、f2和f3都引用了变量i，i最终值为3，所以f1()、f2()和f3()的输出结果都为9
	\end{lstlisting}

	如果想让该变量不发生变化，可以再嵌套一个函数，将这个变量作为函数的参数，如下所示：
	\begin{lstlisting}
	def count():
		fs = []
		for i in range(1, 4):
			def f(j):
				def g():
					return j * j
				return g
			fs.append(f(i))
		return fs
	\end{lstlisting}

\subsection{关键字lambda}
	关键字lambda可以用于创建匿名函数，例子如下所示：
	\begin{lstlisting}
	lambda x: x * x
	# 以上这个匿名函数等价于
	def f(x):
		return x * x
	\end{lstlisting}

	匿名函数只能有一个表达式，返回值就是该表达式的结果。再举一个例子：
	\begin{lstlisting}
	map(lambda x: x*x, [1, 2, 3, 4])
	# 返回[1, 4, 9, 16]
	\end{lstlisting}

	需要知道的是，匿名函数也是一个函数对象，有自己的函数地址，所以可以让变量指向这个函数，如下所示：
	\begin{lstlisting}
	f = lambda x: x*x
	f(5)
	# 输出结果为25
	\end{lstlisting}

\subsection{装饰器}
	装饰器可以在代码运行期间动态地增加功能，在本质上，装饰器就是一个返回函数的高阶函数。
	装饰器的使用如下所示：
	\begin{lstlisting}
	def log(func):
		def wrapper(*args, **kw):
			print 'call %s():' % func.__name__
			return func(*args, **kw)
		return wrapper

	# 以下log就是一个装饰器
	@log
	def now():
		print '2017-2-16'
	\end{lstlisting}

	把@log放到now()函数的定义处，相当于增加了语句：
	\begin{lstlisting}
	now = log(now)
	\end{lstlisting}

	当调用now函数时，实际是执行以下语句：
	\begin{lstlisting}
	now = log(now)
	now()
	\end{lstlisting}

	如果装饰器本身需要传入参数，可以写一个返回装饰器的高阶函数，如下例所示：
	\begin{lstlisting}
	def log(text):
		def decorator(func):
			def wrapper(*args, **kw):
				print '%s %s():' % (text, func.__name__)
				return func(*args, **kw)
			return wrapper
		return decorator

	@log('execute')
	def now():
		print '2017-2-16'
	\end{lstlisting}

	当调用now函数时，实际是执行以下语句：
	\begin{lstlisting}
	now = log('execute')(now)
	now()
	\end{lstlisting}

	需要注意的是，因为返回了wrapper函数，所以now现在指向的是wrapper的地址，now.\_\_name\_\_的值为“wrapper”。
	此时，之后如果有依赖函数签名的代码就会出错。\par

	我们可以使用python内置的functools.wraps将wrapper函数的\_\_name\_\_改为“func”，如下所示：
	\begin{lstlisting}
	import functools

	def log(func):
		@functools.wraps(func)
		def wrapper(*args, **kw):
			print 'call %s()', % func.__name__
			return func(*args, **kw)
		return wrapper
	\end{lstlisting}

\subsection{偏函数}
	偏函数是functools模块定义的一个函数functool.partial，它将一个函数的某些参数给固定住，然后返回一个对应的新函数。\par

	举个例子，int()函数可以把字符串转换为整数。int()函数还提供了额外的base参数，默认值为10，如果传入base=N参数，就可以做N进制的转换。如下所示：
	\begin{lstlisting}
	int('12345')
	# 输出结果为12345
	int('12345', base=8)
	# 输出结果为5349
	\end{lstlisting}

	functools.partial可以帮助我们建立一个偏函数，如下所示：
	\begin{lstlisting}
	int2 = functools.partial(int, base=2)
	int2('1000000')
	# 输出结果为64
	\end{lstlisting}

	需要知道的是，int2函数只是将int函数的base参数设定为默认值2。在实际函数调用时还可以传入其他值，如下所示：
	\begin{lstlisting}
	int2('1000000', base=10)
	# 输出结果为1000000
	\end{lstlisting}

\end{document}
