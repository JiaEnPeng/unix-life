% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=python,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{面向对象编程 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{面向对象编程}
	类class是一种抽象概念，比如学生student就是一个抽象概念。
	而实例instance是一个个具体的student，比如Bart Simpson就是一个具体的student。\par

	面向对象编程的设计思想是抽象出class，然后根据class创建instance。

\subsection{类和实例}
	在python中，定义类是通过class关键字，如下所示：
	\begin{lstlisting}
	class student(object):
		def __init__(self, name, score):
			self.name = name
			self.score = score
	\end{lstlisting}

	这里的object是student的父类，student继承了object类。
	一般来说，如果没有合适的继承类，就使用object类。\par

	创建实例的方式如下所示：
	\begin{lstlisting}
	bart = student('Bart Simnpson', 59)
	\end{lstlisting}

	需要知道的是，在类中定义的函数的第一个参数永远是实例变量self，并且调用类函数时，不用传递这个参数。
	除此之外，类函数和普通函数没有什么区别。

\subsection{访问限制}
	如果想让类的内部属性不被外部访问，可以把属性的名称前加上两个下划线\_\_，这样就变成了私有变量，只有内部可以访问，外部不能访问，如下所示：
	\begin{lstlisting}
	class student(object):
		def __init__(self, name, score):
			self.__name = name
			sekf.__score = score

		def print_score(self):
			print '%s: %s' % (self.__name, self.__score)
	\end{lstlisting}

	需要知道的是，变量名类似\_\_xxx\_\_的，是特殊变量。
	特殊变量可以直接访问，不是private变量。\par

	有时候还可以看到以下划线开头的实例变量名，如\_name，这样的变量外部可以访问。
	但是按照约定俗成的规定，这种变量虽然可以被访问，但是请把它当作私有变量，不要随意访问。\par

	私有变量其实也可以访问，student类中的\_\_name只是被python解释器变成了\_student\_\_name，
	所以仍然可以通过\_student\_\_name访问\_\_name，如下所示：
	\begin{lstlisting}
	bart = student('bart', 100)
	bart._student__name
	# 输出为bart
	\end{lstlisting}

	需要知道的是，不同版本的python解释器会把\_\_name改为不同的变量名，不一定是\_student\_\_name。

\subsection{继承和多态}
\subsubsection{继承}
	当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类，而被继承的class称为基类、父类或超类。\par

	需要注意的是，任何时候，如果没有合适的类可以继承，就继承object类。\par

	例子如下：
	\begin{lstlisting}
	class Animal(object):
		def run(self):
			print 'Animal is running'

	class Dog(Animal):
		pass

	class Cat(Animal):
		pass
	\end{lstlisting}

	继承以后，子类获得父类的所有功能，像Dog和Cat类，就自动拥有了run()方法，如下所示：
	\begin{lstlisting}
	dog = Dog()
	dog.run()
	# 输出结果为'Animal is running'

	cat = Cat()
	cat.run()
	# 输出结果为'Animal is running'
	\end{lstlisting}

\subsubsection{多态}
	当子类和父类都存在相同的方法时，子类的方法将覆盖父类的芳法，在代码运行时，总是会调用子类的方法。\par

	更进一步说，任何依赖Animal作为参数的函数，传入任意的类型，只要是Animal类或者它的子类，就会自动调用实际类型的方法，这就是多态。\par

	如下所示：
	\begin{lstlisting}
	class Animal(object):
		def run(self):
			print 'Animal is running'

	class Dog(Animal):
		def run(self):
			print 'Dog is running'

	class Cat(Animal):
		def run(self):
			print 'Cat is running'

	# 一个依赖Animal作为参数的函数
	def run_test(animal):
		animal.run()

	# 运行时会调用实际类型的方法
	run_test(Animal())
	# 输出'Animal is running'
	run_test(Dog())
	# 输出'Dog is running'
	run_test(Cat())
	# 输出'Cat is running'
	\end{lstlisting}

\subsection{dir()函数}
	使用dir()函数可以获得一个对象的所有属性和方法，如下所示：
	\begin{lstlisting}
	dir('ABC')
	\end{lstlisting}

\subsection{使用\_\_slot\_\_}
	在python中，如果创建一个class实例以后，我们可以给该实例绑定任何的属性和方法，如下所示：
	\begin{lstlisting}
	class student(object):
		pass

	s = student()
	s.name = 'Michael' # 绑定一个属性

	from types import MethodType
	def set_age(self, age):
		self.age = age

	s.set_age = MethodType(set_age, s, student) # 绑定一个方法
	\end{lstlisting}

	我们可以使用\_\_slots\_\_限制class的属性，比如，只允许对student实例添加name和age属性：
	\begin{lstlisting}
	class student(object):
		__slot__ = ('name', 'age')
	\end{lstlisting}

	此时，如果向student的实力绑定其他属性，就会出错：
	\begin{lstlisting}
	s = student()
	s.name = 'Michael'
	s.age = 25
	s.score = 100 # 报错
	\end{lstlisting}

	需要注意的是，\_\_slots\_\_只对当前类起作用，对继承的子类是不起作用的：
	\begin{lstlisting}
	class GraduateStudent(student):
		pass

	g = GraduateStudent()
	g.score = 100 # 绑定一个属性，不会报错
	\end{lstlisting}

\subsection{property类}
	property类是python中的类，它的声明如下所示：
	\begin{lstlisting}
	property(fget=None, fset=None, fdel=None, doc=None)
	class property([fget,[,fset[,fdel[,doc]]]])
	\end{lstlisting}

	通过prproperty函数，可以将一个方法变成属性调用。这说起来有点抽象，可以看如下用法：
	\begin{lstlisting}
	class C(object):
		def __init__(self):
			self._x = None

		def getx(self):
			return self._x

		def setx(self, value):
			self._x = value

		def delx(self):
			del self._x

		x = property(getx, setx, delx, "I'm the 'x' property")
		
	c = C()
	c.x # 将调用c.getx()，输出_x
	c.x = value # 将调用c.setx(value)，设置_x
	del c.x # 将调用c.delx()
	\end{lstlisting}

	可以将property类和@语法配合使用，如下所示：
	\begin{lstlisting}
	class C(object):
		def __init__(self):
			self._x = None

		@property
		def x(self):
			return self._x

	c = C()
	c.x # 输出_x的值
	\end{lstlisting}

	此时，类C中就有一个property类的实例x，可以通过它直接获得\_x的值。\par

	为了进一步了解property，我们来看一下它的实现代码：
	\begin{lstlisting}
	class property(object):
		def __init__(self, fget=None, fset=None, fdel=None, doc=None):
			self.fget = fget
			self.fset = fset
			self.fdel = fdel
			if doc is None and fget is not None:
				doc = fget.__doc__
			self.__doc__ = doc

		def __get__(self, obj, objtype=None):
			if obj is None:
				return self
			if self.fget is None:
				raise AttributeError("unreadable attribute")
			return self.fget(obj)

		def __set__(self, obj, value):
			if self.fset is None:
				raise AttributeError("can't set attribute")
			self.fset(obj, value)

		def __delete__(self, obj):
			if self.fget is None:
				raise AttributeError("can't delete attribute")
			self.fdel(obj)

		def getter(self, fget):
			return type(self)(fget, self.fset, self.fdel, self.__doc__)

		def setter(self, fset):
			return type(self)(self.fget, fset, self.fdel, self.__doc__)

		def deleter(self, fdel):
			return type(self)(self.fget, self.fset, fdel, self.__doc__)
	\end{lstlisting}

	当类中第一次使用@property以后，就返回了property类的实例x，此时上述例子就相当于如下的类：
	\begin{lstlisting}
	class C(object):
		def __init__(self):
			self._x = None

		def getx(self):
			return self._x

		x = property(getx)
	\end{lstlisting}

	根据property类的实现代码可以知道，x此时还有setter、deleter函数可以用来做装饰器，从而进一步增加x的功能，如下所示：
	\begin{lstlisting}
	class C(object):
		def __init__(self):
			self._x = None
		
		@property
		def x(self):
			return self._x

		@x.setter
		def x(self, value):
			self._x = value

		@x.deleter
		def x(self):
			del self._x
	\end{lstlisting}

\subsection{类中特殊的函数}
\subsubsection{\_\_str\_\_函数}
	当打印类时，\_\_str\_\_函数可以返回用户看到的字符串，如下所示：
	\begin{lstlisting}
	class student(object):
		def __init__(self, name):
			self.name = name
		def __str__(self):
			return 'student object (name: %s)' % self.name

	print student('Michael')
	# 输出结果为'student object (name: Michael)'
	\end{lstlisting}

\subsubsection{\_\_repr\_\_函数}
	当直接调用类时，\_\_repr\_\_函数将返回程序开发者看到的字符串，如下所示：
	\begin{lstlisting}
	class student(object):
		def __init__(self, name):
			self.name = name
		def __repr__(self):
			return 'student object (name: %s)' % self.name
	
	s = student('Michael')
	s # 输出结果为'student object (name: Michael)'
	\end{lstlisting}

	可以看出，\_\_str\_\_和\_\_repr\_\_的区别在于，一个要用print打印类，一个直接调用类。

\subsubsection{\_\_iter\_\_函数}
	当类用于for循环时，for循环将调用一次类的\_\_iter\_\_函数，用于初始化被循环的迭代器。
	因此，\_\_iter\_\_函数必须返回一个迭代器，用于for循环。\par

	如下例所示：
	\begin{lstlisting}
	# 本例中Fib类本身就是一个迭代器
	class Fib(object):
		def __init__(self):
			self.a, self.b = 0, 1

		def __iter__(self):
			return self 
			
		def next(self):
			self.a, self.b = self.b, self.a + self.b
			if self.a > 10
				raise StopIteration()
			return self.a

	for n in Fib():
		print n
	\end{lstlisting}

\subsubsection{\_\_getitem\_\_函数}
	如果想让类通过[]接受参数，可以使用\_\_getitem\_\_函数：
	\begin{lstlisting}
	class Fib(object):
		def __getitem__(self, n):
			return n

	f = Fib()
	f[0] # 输出0
	f[1] # 输出1
	f[2] # 输出2
	\end{lstlisting}

\subsubsection{\_\_getattr\_\_函数}
	正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。
	但是如果定义了\_\_getattr\_\_函数，那么被调用的方法或属性不存在时，将调用\_\_getattr\_\_函数。\par

	举个例子：
	\begin{lstlisting}
	class student(object):
		def __init__(self):
			self.name = 'Michael'

		def __getattr__(self, attr):
			if attr == 'score':
				return 99
			if attr == 'age':
				return lambda: 25
	
	s = student()
	s.score # 返回属性，输出结果为99
	s.age() # 返回方法，输出结果为25
	\end{lstlisting}

	需要知道的是，如果__getattr__函数中没有特殊处理，将默认返回None。

\subsubsection{\_\_call\_\_函数}
	通过定义一个\_\_call\_\_()方法，就可以直接对实例进行调用。\par

	举个例子：
	\begin{lstlisting}
	class student(object):
		def __init__(self, name):
			self.name = name
		
		def __call__(self):
			print 'My name is %s.' % self.name

	s = student('Michael')
	s() # 输出结果为'My name is Michael.'
	\end{lstlisting}

	需要知道的是，这个\_\_call\_\_函数是可以接受参数的。

\subsection{type()}
	type()函数可以查看一个类型或变量的类型，还可以创建class。\par

	type()函数既可以返回一个对象的类型，又可以创建出新的类型。具体操作如下所示：
	\begin{lstlisting}
	def fn(self, name='world'):
		print 'Hello, %s.' % name

	Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello类
	\end{lstlisting}

	type()函数依次传入3个参数：class的名称、tuple形式的父类集合、与函数绑定的class方法名称。\par

	通过type()函数创建的类和直接写class是完全一样的，因为python解释器遇到class定义时，也是调用type()函数创建出class。

\end{document}
